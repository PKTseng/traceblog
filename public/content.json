{"pages":[{"title":"","text":"","link":"/tags/index.html"},{"title":"","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index-1.html"},{"title":"categories","text":"","link":"/categories/index-1.html"},{"title":"tags","text":"","link":"/tags/index-2.html"}],"posts":[{"title":"JavaScript - 介紹 this 的指向及觀念","text":"函式裡面一定會帶上一個 this ， this 在執行函式的時候自然就會產生，不需要特別宣告 作用域不一樣，var 的作用域在函數 (function) 裡，let 的作用域則是在區塊 (block) 裡。 範例 112345678910var myName = '驚不驚喜'function callName() { console.log(this, this.myName)}var family = { myName: '老王', callName: callName,}family.callName() this 會指向函式前面的物件，所以 this 顯示 family 物件， this.myName 會顯示老王 範例 2123456789101112131415var myName = '驚不驚喜'function callName() { console.log(this, this.myName)}var family = { myName: '來因', callName: callName, ana: { myName: '安納', callName: callName, },}family.callName()family.ana.callName() 這邊 family 裡面多了 ana 物件，執行 family.callName() 會找到物件第一層，跟範例 1 一樣在執行 family.ana.callName() 時，callName()的 this 會指向 ana 物件 範例 312345678910111213141516var myName = '驚不驚喜'function callName() { console.log(this, this.myName)}var family = { myName: '來因', callName: function () { console.log(this, this.myName) },}// family.callName();var callName = family.callNamecallName() 如果執行 family.callName() 結果會跟範例 1 一樣，但如果重新宣告 callName 再執行結果為什麼會是 驚不驚喜 ?因為callName 是在全域執行，所以 this 就不會指向 family 這個物件，是指向全域的 window ，而全域 window 的 myName 就是 驚不驚喜 。就算少了 var callName = family.callName; 結果仍是一樣 參考資料: JavaScript 核心篇","link":"/2020/08/16/2021this/"},{"title":"Vue - 下拉選單","text":"先將 select 用 v-model 做作雙向綁定，因為 number 是空字串，所以在一開始 option 會指定到 value 為空值的選項。假設 option 裡面沒有 value ，那 option 就會顯示 2020 等年分，但給了 value 就會顯示 value 值。 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;select v-model=\"number\"&gt; &lt;option disabled value=\"\"&gt;select number&lt;/option&gt; &lt;option value=\"001\"&gt;2020&lt;/option&gt; &lt;option value=\"002\"&gt;2021&lt;/option&gt; &lt;option value=\"003\"&gt;2022&lt;/option&gt; &lt;!--&lt;option&gt;2020&lt;/option&gt; &lt;option&gt;2021&lt;/option&gt; &lt;option&gt;2022&lt;/option&gt; --&gt; &lt;/select&gt; &lt;h1&gt;{{number}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { number: '', }, })&lt;/script&gt; codepen 下拉選單還可以綁定到陣列上 1234567891011121314&lt;div id=\"app\"&gt; &lt;select&gt; &lt;option v-for=\"number in numbers\" :value=\"number\"&gt;{{number}}&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { numbers: [2020, 2021, 2022], }, })&lt;/script&gt; 利用 v-for 的方式將 option 內的 value 指定為 number ，在用 v-model 將初始值設定為 2020，範例如下 12345678910111213141516&lt;div id=\"app\"&gt; &lt;select v-model=\"selectNumber\"&gt; &lt;option v-for=\"number in numbers\"&gt;{{number}}&lt;/option&gt; &lt;/select&gt; &lt;h1&gt;{{selectNumber}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { numbers: [2020, 2021, 2022], selectNumber: 2020, }, })&lt;/script&gt; codepen 還有月份選擇，但有更為簡潔的寫法，範例如下 直接在 option 裡面寫最大數字，並將初始值 selectMonth 設定為 1，這樣就有下拉選單裡面有包含 12 個數字 123456789101112131415&lt;div id=\"app\"&gt; &lt;select v-model=\"selectMonth\"&gt; &lt;option v-for=\"month in 12\"&gt;{{month}}&lt;/option&gt; &lt;/select&gt; &lt;h1&gt;{{selectMonth}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { selectMonth: 1, }, })&lt;/script&gt; codepen 陣列包物件寫法透過陣列將陣列內的物件顯示出來 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;select v-model=\"selectGender\"&gt; &lt;option v-for=\"option in options\" :value=\"option.value\"&gt; {{option.text}} &lt;/option&gt; &lt;/select&gt; &lt;h1&gt;{{selectGender}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { options: [ { value: 1, text: 'boy' }, { value: 2, text: 'girl' }, { value: 3, text: 'others' }, ], selectGender: 1, }, })&lt;/script&gt; codepen 參考資料:精通 VueJS 前端開發完全指南","link":"/2021/03/06/%E4%B8%8B%E6%8B%89%E9%81%B8%E5%96%AE/"},{"title":"JavaScript - 執行環境","text":"JavaScript 是直譯式語言當 JavaScript 在函示內找不到變數就會向外查找window === this但 this 會隨執行環境而有所不同 語法作用域 (Lexical scope)12345678910var value = 1function fn1() { console.log(value) // 語法作用域：1 // 動態作用域：2}function fn2() { var value = 2 fn1()}fn2() 語法作用域的順序:(因為 JS 式語法作用域，所以會跑這個步驟)fu2 執行 value 值就會變 2 ，在執行 fn1 ，因為裡面沒有 value 值所以會向外查找全域變數 value = 1，函式執行完結果為 1 動態作用域的順序:全域賦予 value=1，這時候會執行 fn2 ，並且重新定義 value = 2 ，再執行 fn1 ，這時會開始查找 value 值在哪裡，這時因為函式調用的時候才會決定它的作用域，並向上一層函式查找宣告的變數值 範圍鍊123456789101112131415var person = '老媽'function sayHi() { console.log('hi ' + person)}function doMorningWork() { var person = '老爸' function meetAuntie() { var person = '漂亮阿姨' console.log('哈囉～ ' + person) } // sayHi(); //meetAuntie();}sayHi()//doMorningWork(); // 執行 因為 sayHi function 裡面沒有 person 變數，所以會向外尋找 123456789101112131415var person = '老媽'function sayHi() { console.log('hi ' + person)}function doMorningWork() { var person = '老爸' function meetAuntie() { var person = '漂亮阿姨' console.log('哈囉～ ' + person) } sayHi() //meetAuntie();}//sayHi();doMorningWork() // 執行 doMorningWork 函式雖然有 person 變數，但不會影響到 sayHi 函式的範圍練，所以 sayHi 函式一樣會向外尋找 person 變數 123456789101112131415var person = '老媽'function sayHi() { console.log('hi ' + person)}function doMorningWork() { var person = '老爸' function meetAuntie() { var person = '漂亮阿姨' console.log('哈囉～ ' + person) } // sayHi(); meetAuntie()}//sayHi();doMorningWork() // 執行 因為 meetAuntie 函式本身就有 person 變數，所以不會像尋找，結果為 哈囉~ 漂亮阿姨如果把 var person = ‘漂亮阿姨’; 註解掉，那 person 變數會向外尋找。結果為 哈囉~老爸 論是: 只要函式內沒找到相對應的變數，就會像向外一層尋找相對應的變數，直到找到為止 提升先想像記憶體是成對的，左邊的格子表示 key，右邊是 value。再創造環境的時候，會先把 a (變數)放到記憶體裡面(左邊格子)，但這時候還不會給 a 值，所以用 console.log 的時候會 defined ，等到執行時才會把 1 套到 a 裡面。 所以執行環境的時候會先創造環境，創造環境會先把程式碼裡面的變數全部挑出來並存在記憶體上，這個動作稱為”提升 Hoisting”，在這個階段還不會給他值，所以如果在此時去取用這些變數的話，值會是 undefined。到執行環境的時候才會賦予它的值 再創造階段 a 是沒有值的，所以會顯示 undefined，直到宣告階段才會把值帶入 。但是函式會把整個函式內容都先載入，所以函式再創造階段就已經可以運行了。 1234567891011121314151617var ming //創造階段ming = '小名' //執行console.log('ming')callName()function callName() { console.log('呼叫小名')}//會等於下列//-----------------------//創造階段function callName() { console.log('呼叫小名')}//執行callName() 函式表達式寫法:1234callName() //這時候的 callName 是還沒有被定義的var callName = function () { console.log('呼叫小名')} 輸出如下圖: 12345678//創造階段var callName(); //這時候 callName 被定義了但沒給值，所以會undefine//執行callName = function(){ //這時 function 已經被賦予到 callName 這個函式上 console.log('呼叫小名'); } callName(); //才可呼叫 範例:123456789101112131415161718192021// var callName = function () {// console.log('呼叫小明 2');// }// function callName() {// console.log('呼叫小明 1');// }// callName();//以上為原式//-----------------------------------//拆解過後function callName() { // 首先函式優先 創造階段 console.log('呼叫小明 1')}var callName //第2階段才把變數往前移callName = function () { //因為變數往前移的關係，這時 function 已經被賦予到 callName 這個函式上 console.log('呼叫小明 2')}//執行callName() 範例:123456789//創造，函式陳述式優先創造function callName() { console.log('小明')}callName() // 第一次執行function callName() { console.log('杰倫')} 拆解&amp;分析:12345678910// 創造function callName() { console.log('小明')}function callName() { console.log('杰倫')}// 執行callName() // 第一次執行callName() // 第二次執行 兩個函式長一樣，後面得值會蓋掉前面的值 測驗分析:12345678function whosName() { if (name) { name = '杰倫' }}var name = '小明'console.log(name)whosName() 因為創造階段，函式陳述式優先創造，變數 name 只生出記憶體，並未賦予值執行階段，呼叫 whosName 的函式時，name 向外查找 name 變數，但未賦予值，所以在 whosName 裡面的 name 被賦予為”杰倫”的值函式跟一般變數不太一樣，函式陳述式在創造環境階段會被優先載入，記憶體在這個階段就會有函式的完整內容。所以函式在創造環境階段就已經可以被運行。 Not Defined VS undefined12var a ;console.log(a) //輸出 undefined 因為記憶體已經有 a 了，但沒有賦值，所以會跳 undefined同理，記憶體沒有 a 就會跳 Not Defined 12//如果要賦予空值要寫var a = null; 執行緒與同步、非同步JavaScript 是單執行序的語言 1234567891011121314151617181920function eatBreakfast() { console.log('吃早餐')}function washingPlate() { console.log('洗餐盤')}function callSomeone(someone) { console.log('打給' + someone) setTimeout(function () { //這段為非同步，而非同步的任務會移到事件佇列 console.log(someone + '回電') }, 1000) //就算這邊秒數調成0秒，也不會優先執行}function doWork() { var auntie = '漂亮阿姨' eatBreakfast() callSomeone(auntie) washingPlate()}doWork() 同步概念來看的話，這三個概念是依序執行的，不會有早餐沒吃完就跳到洗碗盤去 執行順序為: do work 吃早餐 打給漂亮阿姨，但因為裡面有 SetTimeout 事件，所以會移到”事件佇列”裡面 洗碗 直到 do work 執行完後才會再去執行 SetTimeout 函式 參考資料: JavaScript 核心篇","link":"/2020/06/13/Javascript%20%E6%A0%B8%E5%BF%83%E7%AF%87-%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83/"},{"title":"JavaScript - 監聽事件","text":"學習方向 介面:如何改變事件 事件:如何監聽事件並做出反應 資料:如何跟 sever 交換資料 eventListener 與 callback functioneventListener給一個屬性跟屬性值，再用 document.querySelector 選一個元素並命名為 app ，透過點擊 hello world 做出彈跳視窗，那想做出彈跳視窗必須偵聽事件 addEventListener ，在 addEventListener 前面是事件的動作例如點擊或是按鍵盤…等等，那後面要傳入一個函式。 callback function因為不知道使用者甚麼時候才會觸發函式(做甚麼動作)，所以我們必須跟瀏覽器說一但點擊了甚麼按鈕或是做了什麼動作(事件)，就幫我呼叫那個函式(觸發)，那呼叫函式就是 callback function EX: 123456789101112131415161718192021&lt;div class=\"app\"&gt; &lt;a href=\"#\"&gt;hello world&lt;/a&gt;&lt;/div&gt;&lt;!-- -------------------------------------------&gt;&lt;!-- 匿名函式 比較常見寫法--&gt;&lt;script&gt; let app = document.querySelector('.app') app.addEventListener('click', function () { alert('hello world') })&lt;/script&gt;&lt;!---------------------------------------------&gt;&lt;script&gt; let app = document.querySelector('.app') app.addEventListener('click', onClick) function onClick() { alert('hello world') }&lt;/script&gt; event(e)當我們觸發事件時，瀏覽器就會把參數(event 縮寫為 e)帶入函示裡面。使用 console.log(e) ，可以看到很多關於 e 的參數。 123456789&lt;div class=\"app\"&gt; &lt;a href=\"#\"&gt;hello world&lt;/a&gt;&lt;/div&gt;&lt;script&gt; let app = document.querySelector('.app'); app.addEventListener('click',function(e){ console.log(e);&lt;/script&gt; 改用 console.log(e.target) 當然如果想知道按鍵參數的話可以這樣寫先改為全域 window 1234567&lt;input type=\"text\" class=\"app\" /&gt;&lt;script&gt; window.addEventListener('keypress', function (e) { console.log(e.keyCode) })&lt;/script&gt; 分別按下 a、b、c，可以知道 a = 97 、b = 98、c = 99 表單事件處理 onSubmit這可以應用在表單二次確認密碼的時候寫出一個簡單的表單，並在判斷式內擷取密碼的值( value ) 1234567891011121314151617&lt;form class=\"login\"&gt; username:&lt;input type=\"text\" /&gt; &lt;br /&gt; password:&lt;input type=\"password\" class=\"password\" /&gt; &lt;br /&gt; password:&lt;input type=\"password\" class=\"password1\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt;&lt;scrip&gt; let login = document.querySelector('.login'); login.addEventListener('submit',function(e){ let psw = document.querySelector('.password'); let psw1 = document.querySelector('.password1'); if(psw.value !== psw1.value){ alert('密碼錯誤'); e.preventDefault(); }else{ alert('密碼正確'); } })&lt;/scrip&gt; codepen 事件傳遞機制-捕獲跟冒泡事件12345678910111213141516&lt;div class=\"one\"&gt; &lt;div class=\"two\"&gt; &lt;button&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; addEvent('.one') addEvent('.two') addEvent('button') function addEvent(className) { document.querySelector(className).addEventListener('click', function () { console.log(className) }) }&lt;/script&gt; codepen 當我點擊綠色區塊的時候只會跳出 one ，但點擊 click 時就會跳出上圖，但我明明只點 click 為甚麼會連帶影響到其他 class 區塊 ? 因為這就是事件傳遞機制的捕獲跟冒泡事件 Huli 文章下圖來源為 Huli 的文章以下這段話擷取自 Huli 文章 DOM 的事件在傳播時，會先從根節點開始往下傳遞到 target，這邊你如果加上事件的話，就會處於 CAPTURING_PHASE，捕獲階段。target 就是你所點擊的那個目標，這時候在 target 身上所加的 eventListenr 會是 AT_TARGET 這一個 Phase。你在點擊那一個 td 的時候，這一個點擊的事件會先從 window 開始往下傳，一直傳到 td 為止，到這邊就叫做 CAPTURING_PHASE，捕獲階段。接著事件傳遞到 td 本身，這時候叫做 AT_TARGET。最後事件會從 td 一路傳回去 window，這時候叫做 BUBBLING_PHASE，冒泡階段。所以，在看一些講事件機制的文章的時候，都會看到一個口訣：先捕獲，再冒泡 在監聽時函式後面加上 true 就是捕獲，false 是冒泡 123456789101112131415161718192021addEvent('.one')addEvent('.two')addEvent('button')function addEvent(className) { document.querySelector(className).addEventListener( 'click', function () { console.log(className, '捕獲') }, true ) document.querySelector(className).addEventListener( 'click', function () { console.log(className, '冒泡') }, false )} codepen 當我點擊 click 就算我把順序顛倒過來，它還是會先捕獲在冒泡，跟上圖一樣 資料來源: [FE102] 前端必備：JavaScript","link":"/2020/07/16/JavaScript%20%E7%B6%B2%E9%A0%81%E4%BA%8B%E4%BB%B6%E8%99%95%E7%90%86/"},{"title":"Html - Flex 上課筆記","text":"Note:display:必備屬性flex-direction:決定 flex 軸線justify-content:主要軸線的對齊align-items:交錯軸線的對齊 Flex 外層屬性 (container) 介紹父元素有 display:flex，內層子元素之間的比例就會自動調整位置 1234.container .item.item1 1 .item.item2 2 .item.item3 3 即使 item 寬度調成 200 5000 10000 px，也不會超出 container，因為父層有 display:flex，但內層如果單一設定高度，其他項目也會跟著一起變更高度若在 item1、2、3 個別加上屬性值會呈現下圖 1234567891011121314151617181920212223242526.container { width: 500px; background: #0099ff; margin: 0 auto;}.container .item { background: #00ffa2; color: #d32a2a; text-align: center; font-size: 36px; margin-bottom: 10px;}.container .item1 { height: 150px; width: 150px;}.container .item2 { height: 200px; width: auto; //因為沒設定寬度，所以會自適應延伸父元素， //父元素寬多少ex:500px，子元素寬就會多少ex:500px}.container .item3 { height: auto; width: 400px;} 即使 item 寬度調成 200 5000 10000 px，也不會超出 container，因為父層有 display:flex，但內層如果單一設定高度，其他項目也會跟著一起變更高度 若在 item1、2、3 個別加上屬性值 1234567891011121314151617181920212223242526.container { width: 500px; background: #0099ff; margin: 0 auto;}.container .item { background: #00ffa2; color: #d32a2a; text-align: center; font-size: 36px; margin-bottom: 10px;}.container .item1 { height: 150px; width: 150px;}.container .item2 { height: 200px; width: auto; //因為沒設定寬度，所以會自適應延伸父元素， //父元素寬多少ex:500px，子元素寬就會多少ex:500px}.container .item3 { height: auto; width: 400px;} 會呈現下圖若在.container css 加上 display: flex 跟 .item + margin: 0 0 10px 10px會呈現下圖item3 因為沒設定高度，所以會依照.item2 的高度自適應延伸item1 因為”有”設定高度，所以不會自適應延伸如果 item 都沒設定高度，就會依照元素內的內容設定高度note: item 預設是等高(or 寬)的，會依照 container 內部距離自動調整 codepen 範例 Flex-direction 排版方向flex-direction: row flex-direction: row-reverse flex-direction: colume flex-direction: colume-reverse justify-content — 決定主軸對齊方式 123display: flexflex-direction: columnjustify-content: space-between 要改變方向要下 display: flex &amp; flex-direction: column(垂直)row 橫向本身是預設可不寫 六角 Flex 模擬器TEST CSS FLEXBOX RULES 資料來源:六角學院-Flex 網頁排版技巧資料來源:職人必修的 RWD 網頁入門班","link":"/2020/06/13/Flex%20%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/"},{"title":"Vue - 列表渲染","text":"8-1 用 v-for 把陣列轉換為一組元素將 data 裡面的 todo 陣列顯示在 li 上，v-for=\"todos in todo\" 後面的todos 代表陣列，前面的todo 代表陣列裡面的每個元素 12345&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"todos in todo\"&gt;{{todos}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456new Vue({ el: '#app', data: { todo: ['html', 'javascript', 'css'], },}) 下拉選單12345&lt;div id=\"app\"&gt; &lt;select&gt; &lt;option v-for=\"month in months\"&gt;{{month}}&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 123456new Vue({ el: '#app', data: { months: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], },}) codepen 這種數字的有另一個寫法，可以將 months 改寫成數字，而改寫的數字就會是最大值，而 months 的陣列可以刪除。範例如下: 12345&lt;div id=\"app\"&gt; &lt;select&gt; &lt;option v-for=\"month in 30\"&gt;{{month}}&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 1234new Vue({ el: '#app', data: {},}) 這樣就會有 30 個數字選項 月份綁 value這是在陣列是字串下，但又希望 value 值是數字 123，這時可以在 month 後面加上 index 或是 idx 、 i 等等任意變數，再用 v-bind 綁 value 12345&lt;div id=\"app\"&gt; &lt;select&gt; &lt;option v-for=\"(month, index) in months\" :vlaue=\"index+1\"&gt;{{month}}&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 12345678910111213141516171819new Vue({ el: '#app', data: { months: [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', ], },}) codepen 8-2 用 v-for 把一個物件轉換為一組元素如果要取物件內的 key 值，就在 value 後面加上 key 就好跟陣列很像，陣列是 (元素, idx) ，物件是 (value, key) 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"(value, key) in obj\"&gt;{{key}} : {{value}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { obj: { // 前面為 key: 後面為 value name: 'PKT', number: '123456', age: '22', }, }, })&lt;/script&gt; v-for 轉物件，渲染出來的順序不一定會跟我寫的一樣，例如我用不規律的數字做開頭 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"(value, key) in obj\"&gt;{{key}} : {{value}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { obj: { name: 'PKT', number: '123456', age: '22', 12: '中餐', 8: '早餐', 6: '晚餐', 2: '宵夜', }, }, })&lt;/script&gt; 渲染出來的結果會長這樣明明我的順序是 12 =&gt; 8 =&gt; 6 =&gt; 2，但是選染出來卻是按照順序排列，這是因為我們用 v-for 來轉物件，若真要按照順序排列的話 code 也不會這樣打，但這是特定情況，必須依照我寫 code 的順序排列，所以就要用 v-for 轉陣列的方式，來修正。 先把物件轉陣列型式，並且在陣列內新增 prop &amp; value 屬性再把 v-for 轉成陣列，下面的 obj 是陣列 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"item in obj\"&gt;{{item.prop}} : {{item.value}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { obj: [ { prop: 'name', value: 'PKT' }, { prop: 'number', value: '123456' }, { prop: 'age', value: '22' }, { prop: 12, value: '中餐' }, { prop: 8, value: '早餐' }, { prop: 6, value: '晚餐' }, { prop: 2, value: '宵夜' }, ], }, })&lt;/script&gt; code這樣就可以依照我指定的順序來顯示了 修改陣列或物件的注意事項常用語法： push: 新增數字 pop: 減少數字 shift: 移除並回傳陣列的第一個元素 unshift: 從陣列開頭塞數字 splice: 從頭數到第 X 個，移除 Y 個，加入 Z sort: 把亂掉的順序，按順序排列 reverse: 順序顛倒 12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"item in nums\"&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;button @click=\"add\"&gt;add&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { nums: [1, 2, 3, 4, 5], // sort 用 // nums:[1,3,5,7,2,4,6,8], }, methods: { add() { // this.nums.push(this.nums.length+1); // this.nums.pop(); // this.nums.shift(); // this.nums.unshift(0); // this.nums.splice(idx, length); // this.nums.splice(2, 1, 9,8,7,); // // this.nums.sort(); // this.nums.reverse(); }, }, })&lt;/script&gt; code filter文件filter 會把陣列內的所有元素拿去跑函式，同時又不會更動原本的陣列，而是產生新的陣列。那函式跑完回傳的值是 true ，就會產生新的陣列，是 false 就不會有新元素出現在新陣列內。 簡言之，就是把原本的陣列過濾並產生新的陣列。 1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"item in nums\"&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;button @click=\"add\"&gt;add&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { nums: [1, 2, 3, 4, 5, 6, 7, 8, 9], }, methods: { add() { this.nums = this.nums.filter((elm) =&gt; elm % 2 === 0) }, }, })&lt;/script&gt; code過濾後會變成下圖 修改陣列並反應在元素上想感變陣列內的值可以用 splice 12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"item in nums\"&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;button @click=\"add\"&gt;add&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { nums: [1, 2, 3, 4, 5, 6, 7, 8, 9], }, methods: { add() { // 這樣是不會有任何反應的 // this.nums[0] = 10; // 從第2個，移除1個，加入789 或是 單值 // 從第0開始算，移除1開始算 // this.nums.splice(2, 1, 7,8,9); // 從第 X 個之後都移除掉 // 移除1開始算 // this.nums.splice(2); // 只保留從 X 到 Y，其他移除掉 // 從第0開始算，移除1開始算 // slice(從, 第) // this.nums = this.nums.slice(1, 4); }, }, })&lt;/script&gt; code 物件內新增值以上都是 v-for 轉陣列，現在是轉物件，並在物件內新增值 新方法 $set(設定屬性的物件, 設定物件的 key, key 的值) 1234567891011121314151617181920212223242526272829&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"(item, key) in nums\"&gt;{{key}}: {{item}}&lt;/li&gt; &lt;/ul&gt; &lt;button @click=\"add\"&gt;add&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { nums: { x: 10, y: 20, }, }, methods: { add() { // 這樣是無法新增的 // this.nums.z = 30; this.$set(this.nums, 'z', 30) // 除了 $set 還可以用 Vue，但是用 Vue 就沒有$ Vue.set(this.nums, 'z', 30) }, }, })&lt;/script&gt; code這樣就可以新增了 以上是示範物件內原本沒有的，但是要新增新的物件，才會用到 set那如果原本就有的，但是要修改原本的物件要怎麼寫? 以下示範 1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"(item, key) in nums\"&gt;{{key}}: {{item}}&lt;/li&gt; &lt;/ul&gt; &lt;button @click=\"add\"&gt;add&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { nums: { x: 10, y: 20, }, }, methods: { add() { this.nums.x = 30 }, }, })&lt;/script&gt; code 參考資料:精通 VueJS 前端開發完全指南","link":"/2021/03/02/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"},{"title":"Vue - 輸入框雙向綁定","text":"文字輸入v-model 可以做雙向綁定，但它同時也等於 v-bind 的 value 跟偵聽 input 的事件。 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;!-- &lt;input type=\"text\" v-model=\"message\"&gt; --&gt; &lt;input type=\"text\" :value=\"message\" @input=\"setMessage\" /&gt; &lt;h1&gt;{{message}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { message: '', }, methods: { setMessage(e) { this.message = e.target.value }, }, })&lt;/script&gt; codepensetMessage 函式會接收一個參數(evt 事件)，並用事件發出的 target 找到 input 元素，那 e.target.vlaue 就是使用者輸入的值。 多行輸入: textarea用 v-model 一樣可以雙向綁定，但是他不會換行，範例如下 12345678910111213&lt;div id=\"app\"&gt; &lt;textarea v-model=\"message\"&gt;&lt;/textarea&gt; &lt;h1&gt;{{message}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { message: '', }, })&lt;/script&gt; codepen 這時候就要用 pre 標籤，它可以保存 message 裡面的換行字元，範例如下 1234567891011121314&lt;div id=\"app\"&gt; &lt;textarea v-model=\"message\"&gt;&lt;/textarea&gt; &lt;!-- &lt;h1&gt;{{message}}&lt;/h1&gt; --&gt; &lt;pre&gt;{{message}}&lt;/pre&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { message: '', }, })&lt;/script&gt; codepen 或是不想用 pre 標籤鄉用 h1 的話可以在 css 裡面加上 white-space: pre; 也會有同樣的效果。 也可以套用一開始單行 v-model 一開始單行 v-model 轉換成 v-bind 跟 v-on 一樣可以運行 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;textarea @input=\"setMessage\"&gt;{{message}}&lt;/textarea&gt; &lt;pre&gt;{{message}}&lt;/pre&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { message: '', }, methods: { setMessage(e) { this.message = e.target.value }, }, })&lt;/script&gt; codepen 參考資料:精通 VueJS 前端開發完全指南","link":"/2021/03/04/%E8%A1%A8%E5%96%AE%E7%B6%81%E5%AE%9A/"},{"title":"Vue - 表單綁定—按鈕","text":"checkbox單選互動按鈕:將 true &amp; false 綁定到一個值上面，並做出沒勾選的話就會跳出 alert 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" id=\"chk\" v-model=\"agree\" /&gt; &lt;label for=\"chk\"&gt;agree&lt;/label&gt; &lt;h1&gt;{{agree}}&lt;/h1&gt; &lt;button @click=\"submit\"&gt;submit&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { agree: false, }, methods: { submit() { if (this.agree !== true) { alert('agreeeeeeee') return } // 表單送出後要做的事情... }, }, })&lt;/script&gt; codepen 多選互動按鈕:這可以應用在客戶在什麼時段方便取貨或是什麼時方便聯絡等地方。 給定三個時段，也給三個時段的 value ，同時在點選時段的時候我希望能以陣列的方式呈現 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;h1&gt;可以聯絡的時段:&lt;/h1&gt; &lt;input type=\"checkbox\" id=\"chk1\" value=\"8:00~12:00\" v-model=\"times\" /&gt; &lt;label for=\"chk1\"&gt;morning&lt;/label&gt; &lt;input type=\"checkbox\" id=\"chk2\" value=\"13:00~ 18:00\" v-model=\"times\" /&gt; &lt;label for=\"chk2\"&gt;afternoon&lt;/label&gt; &lt;input type=\"checkbox\" id=\"chk3\" value=\"19:00~21:00\" v-model=\"times\" /&gt; &lt;label for=\"chk3\"&gt;evening&lt;/label&gt; &lt;h2&gt;{{times}}&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { times: [], }, })&lt;/script&gt; codepen透過勾選的順序決定誰要先呈現第一個，例如我先勾選 evening 再勾 afternoon 就會呈現下圖順序 radio這是應用在表單填寫性別或是單個選項等地方。給 2 個選項，在點擊 label 時會呈現 value ，要額外呈現 value 就要用 ， v-model 做雙向綁定，那 v-model 要空值或是預設值都可以。 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;input type=\"radio\" id=\"chk1\" value=\"male\" v-model=\"gender\" /&gt; &lt;label for=\"chk1\"&gt;male&lt;/label&gt; &lt;input type=\"radio\" id=\"chk2\" value=\"female\" v-model=\"gender\" /&gt; &lt;label for=\"chk2\"&gt;female&lt;/label&gt; &lt;h1&gt;{{gender}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { gender: 'male', }, })&lt;/script&gt; codepen 參考資料:精通 VueJS 前端開發完全指南","link":"/2021/03/03/%E8%A1%A8%E5%96%AE%E7%B6%81%E5%AE%9A%E2%80%94%E6%8C%89%E9%88%95/"},{"title":"Vue - 計算屬性 ( computed )","text":"計算用法: 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;input type=\"number\" v-model=\"a\" /&gt; + &lt;input type=\"number\" v-model=\"b\" /&gt; = &lt;input type=\"text\" v-model=\"ans\" /&gt; &lt;br /&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { a: 0, b: 0, c: 0, }, computed: { ans() { return parseInt(this.a) + parseInt(this.b) }, }, })&lt;/script&gt; codepencomputed 裡面的屬性不能跟 data、methods 撞名，同樣的在 ans 不能是箭頭函式，因為用箭頭函式，那 ans 裡面的 this 就會是 window 物件 除了簡單的計算外還有進階的用法，就是 computed 裡面除了宣告成函式外還可以宣告成物件 123456789101112131415161718new Vue({ el: '#app', data: { a: 0, b: 0, c: 0, }, computed: { ans: { get() { return parseInt(this.a) + parseInt(this.b) }, set(val) { this.b = parseInt(val) - parseInt(this.a) }, }, },}) codepenget 是指，當我需要 ans 值的時候，就會用 get 呼叫函式，取出 return 的值 set 是指，當我設定某個值到 ans 的時候，要用 set 的函式，那 set 函式它吃一個值( value )，範例是當我設定 ans 的時候就要算出 a or b 的值 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/09/25/%E8%A8%88%E7%AE%97%E5%B1%AC%E6%80%A7(computed)/"},{"title":"jQuery - 基本使用","text":"事件分以下四種事件: 單擊 (click) 雙擊 (dblclick) 滑鼠移入 (mouseenter) 滑鼠移出 (mouseleave) 1. 單擊 (click) &amp; 雙擊 (dblclick)為了方便區分，將 id 設定成 click &amp; dbiclick。 接下來就是 jquery 三步驟: 選擇要改變的元素 id 更改的樣式 .css('color', 'red') 動作: 單擊 or 雙擊 12&lt;h1 id=\"click\"&gt;click&lt;/h1&gt;&lt;h1 id=\"dblclick\"&gt;dbiclick&lt;/h1&gt; 1234567$('#click').click(function () { $(this).css('color', 'red')})$('#dblclick').dblclick(function () { $(this).css('color', 'blue')}) 原圖: 當我單擊的時候會顯示下圖: 雙擊如下圖: DEMO 如何知道 API 可以參考 W3Schools 2. 滑鼠事件，移入(mouseenter)與移出(mouseout)給兩個方塊測試，當滑鼠移入或移出方塊的時候就會顯示移入或移出的 log。 其中 mouseenter 事件跟 hover 一樣，在移入時都會有相同動作。 12&lt;div id=\"red\"&gt;&lt;/div&gt;&lt;div id=\"blue\"&gt;&lt;/div&gt; 1234567891011#red{ width: 100px; height: 100px; background: red;}#blue{ width: 100px; height: 100px; background: blue;} 1234567$('#red').mouseenter(function () { console.log('滑鼠移入紅色')})$('#blue').mouseleave(function () { console.log('滑鼠移出藍色')}) 當滑鼠移入的時候 當滑鼠移出的時候 DEMO 3. W3Schools","link":"/2021/01/13/jQuery%20-%20%E4%BA%8B%E4%BB%B6%20(event)/"},{"title":"Vue - loading 效果","text":"套件首先安裝 npm: npm install vue-loading-overlay再到 main.js 載入 1234567// Import componentimport Loading from 'vue-loading-overlay'// Import stylesheetimport 'vue-loading-overlay/dist/vue-loading.css'// 因為是全域每個 component 都會用，所以用 Vue.componentVue.component('Loading', Loading) 全域 Loading接下來要在 components 裡面加入讀取的判斷式跟綁定先將 lading 預設好，只有在等待的時間下才會轉 isLoading: false, 然後把範例拿過來用 在 div 內一層加上 &lt;loading :active.sync=\"isLoading\"&gt;&lt;/loading&gt; 接下來要在 AJAX 的行為上面新增 isLoading: false,在啟用 getProducts 的時候就會觸發 loading ( true )，在完成的時候結束( false )範例如下: 12345678getProducts() { const api = `${process.env.APIPATH}/api/${process.env.MYPATH}/products` this.isLoading = true this.$http.get(api).then((response) =&gt; { this.products = response.data.products this.isLoading = false })}, 然後再重新整理，畫面中間就會出現 Loading 的效果，再試試按下編輯或是新增然後直接按下確認也會有 Loading 的效果 這樣全域就完成了!! 局部 Loading再來要做局部的，我們要在新增或是編輯圖片那邊加上 loading 的效果 要加的地方在下圖紅框處 這邊偷懶一下直接用 CDN 載入 font-awesome 到 index.html 然後再到 Animating Icons 選一個自己喜歡的 loading 樣式這邊用 fa-spinner fa-spin 作範例因為要在上傳圖片的旁邊顯示 loading 效果，所以我們把 fa-spinner fa-spin 加在 label 旁邊， 再到 data 函式加入決定局部 loading 的變數 再到模板那邊用 v-if 判斷做動態綁定 然後在上傳圖片的函示( uploadImg )內加入局部 loading 判斷 12345678910111213141516171819202122232425uploadImg() { // 在拉圖片進去讀取的時候 fileUpLoading 會是 true this.status.fileUpLoading = true const uploadFile = this.$refs.files.files[0] const formData = new FormData() formData.append('file-to-upload', uploadFile) //接下來定義路徑 const url = `${process.env.APIPATH}/api/${process.env.MYPATH}/admin/upload` this.$http .post(url, formData, { headers: { 'Content-Type': 'multipart/form-data' } }) .then((res) =&gt; { console.log(res.data) // AJAX 結束後 fileUpLoading 就 false this.status.fileUpLoading = false if (res.data.success) { // this.tempProduct.imgUrl = res.data.imageUrl console.log(this.tempProduct) this.$set(this.tempProduct, 'imgUrl', res.data.imageUrl) } })}","link":"/2021/03/10/loading/"},{"title":"Vue - Axios & Bootstrap 引入","text":"相關文件API文件進度 commit 由於 Google Chrome 在後續 80 版本後會預設封鎖第三方 Cookie，所以在登入 Vue 課程 API 就會出現無法登入的問題，在這邊老師也補充相關解決方式連結 啟用一個 Vue Cli 並且 引用帶入專屬 API申請 API ，並載入先申請 API ，取得資料再安裝 Vue-Axios ，然後把 Vue-Axios 載入到 main.jsmain.js 載入順序是第三方套件盡量往上放，下面再放自己撰寫的組件 12345678// 第三方套件import Vue from 'vue'import axios from 'axios'import VueAxios from 'vue-axios'// 自己撰寫import App from './App'import router from './router' main.js 載入後到 app.vue 組件，透過 apiurl 網址來取得遠端資料，在 apiurl 下面有範本，可以直接取用 12345678910111213141516&lt;script&gt;export default { name: 'App', // 取得遠端資料 created() { const api = 'https://vue-course-api.hexschool.io/api/pkt/products' //api申請的路經 //所申請的API path this.$http.get(api).then((response) =&gt; { console.log(response.data) }) },}&lt;/script&gt; 然後用 console 確認 API 資料有沒有載入(記得刷新頁面)，查看產品裡面有個測試分類，確認是否跟自己的 API 一樣 修改 API 路徑，確認是否有抓到API 路徑在開發時段有可能會修改，為了方便管理，所以要去 config/dev.env.js 新增變數(dev.env.js 是開發中的環境，prod.env.js 是正式上線的環境) 123456789101112131415module.exports = merge(prodEnv, { NODE_ENV: '\"development\"', APIPATH:'\"https://vue-course-api.hexschool.io\"',// 這是伺服器路徑 COSTOMPATH:'\"pkt\"',// 這是自定義的路徑})------------下面這塊是重要提醒!!!!!!-------------------APIPATH路經尾巴不能有\"/\"，不然會出現\"你所查看的API不存在\"路徑是外面一個單引號，裡面再用雙引號包住錯誤示範:APIPATH:'https://vue-course-api.hexschool.io/',正確示範:APIPATH:'\"https://vue-course-api.hexschool.io\"', 新增好變數後就可以把路徑用字串模板跟變數的方式來呈現我們要確認 dev.env.js 的路徑是否有啟用，所以在 app.vue 輸入console.log(process.env.APIPATH, process.env.COSTOMPATH); 輸入完若直接刷新頁面會出現下圖，顯示抓不到路徑這是正常的，解決方法是重新起動 vue npm run rdv !!! 再用 console 查看，就會正常顯示了 將路徑改成字串模板+變數確認變數有抓到後，接下來要把路經改用字串模板+變數來呈現(單引號記得改反引號) 123456789101112131415161718&lt;script&gt;export default { name: 'App', // 取得遠端資料 created() { // 字串模板記得改成 反引號!!! const api = `${process.env.APIPATH}/api/${process.env.COSTOMPATH}/products`; // console.log(process.env.APIPATH, process.env.COSTOMPATH); //api申請的路經 //所申請的API path this.$http.get(api).then((response) =&gt; { console.log(response.data) }) },}&lt;/script&gt; 然後重開 npm，確認是否抓到 引用 Bootstrap 套件，並客製化樣式接下來要將 Boostrap4 變數修改成自定義的變數，在此之前要先建立新的檔案並且把原本的變數檔存到要修改的資料夾內。Dashboard 模板首先用 npm 載入 Boostrap4npm install Boostrap --savenpm install --save-d sass-loader@7.1.0會限制版本是為了避免在&lt;style lang=\"scss\"&gt; 出錯，如下圖，此圖來源為 Simon 同學的範例為避免這狀況發生，所以這邊用舊版本示範 安裝好 npm 後重開，到 node_modules 資料夾下確認是否有載入 然後到 app.vue 把預設的 CSS 刪掉，並載入 Bootstrap4 1234&lt;style lang='scss'&gt;@import '~bootstrap/scss/bootstrap';//~bootstrap 是指載入 Boostrap 這個模組&lt;/style&gt; 這時候有可能是 sass-loader 沒裝，每個 cli 出來的 webpaack 版本可能會不一樣，如果沒跳錯就沒問題，如果有跳錯(如下圖)那就裝一下 npm i node-sass sass-loader --save ，再重開就好了 建立資料夾，新增檔案，拉連結接下來要客製化一些變數，這時候就需要將 Boostrap4 獨立出來，方便自定義跟管理 先在 assets 資料夾下新增 helper 資料夾，在到 node_modules / Bootstrap4 / SCSS / variables.scss，把 variables 另存新檔到 helper 資料夾內，這樣透過修改 variables 就可以將原本 Boostrap4 樣式進行客製化了 然後建立一個新的 all.scss 檔案，並載入方法跟要客製化的檔案 123@import '~bootstrap/scss/functions'; //載入 Boostrap4 套用變數的方法@import './helper/variables'; //有了上面的方法，才可以啟用自己定義的變數@import '~bootstrap/scss/bootstrap'; 再把 app.vue 的 style 改成下圖 1@import './assets/all'; //不要複製造抄，請確認 all.scss 放在哪 到目前為止，畫面仍會是正常的(如下圖) 接下來要加入 Bootstrap4 樣式來看看會有什麼變化，這邊用 button 套件示範把套件放在 app.vue 的 router-view 下方(如下圖) 這時候畫面就會顯示按鈕 現在要改樣式，先到 variables.scss 找要改的變數，這邊用 ‘indigo’ 示範 找到主題色做更改，這時候 primary 的顏色會被改掉 scopedscoped 是將樣式限制在某個組件內，以下示範先到 helloworld 組件看一下樣式會發現預設樣式是 scoped，代表這些樣式只會在 helloworld 組件內執行，不會影響到外層 app 組件 我們先看 router 配置圖可以看到 helloworld (內層)組件是被 app (外層)組件包住的，雖然是包住的但內外層是互不影響的，因為有 scoped 的關係，讓它們之間天人永隔! 我們先看看 helloworld (內層) style 裡的 a 連結，預設是 #42b983 淡綠色， 然後我們在 app (外層)組件內加入 a 連結 刷新畫面後，可以看到 a 連結的顏色會是紫色不是淡綠色，這是因為在 helloworld 有下 scoped ，所以樣式不會互相影響 如果文字看不懂，就看這張吧 如果不想讓各組件之間的樣式互相影響的話就必須在 style 加上 scoped ! 資料來源: Vue 出電商網站","link":"/2020/08/10/Axios/"},{"title":"Vue - 避免顯示陣列內重複的值","text":"在寫個人專案的過程中遇到一些問題，順便記錄一下。 要做的需求是 sidebar 顯示電影類型。 進入頁面獲取資料在進入頁面的時候我們必須發送請求跟後端索取資料，後端接受到前端的請求後會進行邏輯判斷再回傳 response 。 要獲取資料就要用 AJAX 的方式，我選用 Axios 來獲取。再將後端回傳的資料賦予到 products 變數裡面。 this 是指向這個 vue 實體。 1234567891011121314151617181920data() { return { products: [], categories: [], }},methods: { getProducts: function () { const api = 'url' Vue.axios.get(api).then(response =&gt; { // console.log(response) this.products = response.data this.getCategories() }) }},mounted() {this.getProducts()}, 用 console.log 看一下回傳的資料。 製作 sidebar 類型選單因為同類型的電影不只一個，會重複很多個，所以要把重複的過濾掉。 思考方向: 第一次先用 map 將所有電影類型全部找出來放到新的陣列裡面。 第二次用 filter 將重複的電影過濾掉。 下圖是 response.data 陣列內回傳的資料，我們要索取陣列內每筆物件的 product_type 屬性。 因為非同步的關係，必須等到後端回傳 response 的時候再執行。所以要在打完 api 回傳 response 後，加上 getProducts() 這個函式，這樣才可以同步。 首先我把 this.products 所有資料用 map 函式塞選一遍， map 條件為將資料內的 product_type 屬性塞選出來放到新的陣列裡面。新的陣列我用 categories 命名。 123456getCategories: function () { let categories = this.products.map(element =&gt; { // console.log(element.product_type) return element.product_type }) }, 用 console.log() 看 element.product_type ， 如下圖( 資料是從 TMDB 用爬蟲爬得，所以會有簡體字 ) map 會產生新的陣列，新陣列內的資料有重複的電影類型，為了不要讓重複的電影類型顯示出來，我用 filter 方法，條件判斷是用 indexOf 。 indexOf : 比較 array 裡面是否有元素 === 你要找的東西。indexOf 的用法可以參考這篇文章 12345678910getCategories: function () { let categories = this.products.map(element =&gt; { return element.product_type }) this.categories = categories.filter( (item, index) =&gt; categories.indexOf(item) === index ) console.log(this.categories)}, 塞選完會呈現下圖 重複的電影類型就不見了 接下來把類型放到陣列裡面，再用 v-for 的方式渲染出來，如下圖 這樣就完成了!!! 參考資料JS 找出元素索引值的陣列 Array 方法 indexOf()","link":"/2021/03/21/%E9%81%BF%E5%85%8D%E9%A1%AF%E7%A4%BA%E9%99%A3%E5%88%97%E5%85%A7%E9%87%8D%E8%A4%87%E7%9A%84%E5%80%BC/"},{"title":"Vue - 顯示類型的數量 ( count )","text":"需求: Sidebar 要顯示電影類型的數量，如下圖 進入網頁時前端會發送請求就是打 api ，那後端收到請求後會回傳 response ，如下圖。 再把 response 裡面的 data 裡面的資料賦予到 this.products 裡面。 因為 AJAX 非同步的關係，為了確保執行程式時式有拿到資料的，所以會在打完 api 後同時執行 getCategories() 這個函式。 123456789101112131415161718192021data() { return { products: [], categoryWithCount: {}, categories: [], }},methods: { getProducts: function () { const api = `url` Vue.axios.get(api).then(response =&gt; { console.log(response.data) this.products = response.data this.getCategoryWithCount() }) },},mounted() {this.getProducts()}, 經過 專案筆記 Vue 避免顯示陣列內重複的值 的解釋，已經把電影的類型賦予到 category 陣列上，現在要用 category 陣列內的值，判斷相同的類型有幾個。 思考方向:先抓取 category 陣列內的值，把這個 category 值跟 products 的值做比對。( products 是打完 api 回傳的資料，資料被賦予到 products 陣列內 ) category : 陣列是已經被過濾的電影類型，所以不會有重複的值 ( 請參考 專案筆記 Vue 避免顯示陣列內重複的值 )。products : 是後端回傳 response 後沒經過處裡的資料。 首先，在 for of 迴圈外用 console.log() 看一下 categories 陣列內的值。 123456getCategoryWithCount: function () { console.log(this.categories) //迴圈外面 for (const category of this.categories) { console.log(category) //迴圈裡面 }}, 會是一個陣列，如下圖 在 for of 迴圈內讀取陣列內的每個值，會從陣列中個別取出，如下圖 透過迴圈已經將值個別取出，再把這些個別的值跟 products 陣列內的值做比對。 用 forEach 迴圈讀取 this.products 所有值。forEach 第一個參數 element 會指向代進去的所有值。 1234567getCategoryWithCount: function () { for (const category of this.categories) { this.products.forEach(element =&gt; { console.log(element) }) }}, 如果不知道 element ，用 console.log() 看一下就知道了，如下圖element 會指向 products 陣列內每一筆的物件。 然後在最外層宣告一個空物件，每跑一次迴圈相同的電影類型就會 +1。在 for 迴圈裡面加入 if 判斷式，有相同電影類型的話那電影類型的數量就會 +1 ，當電影類型的型別判斷是 undefined 的話就會被歸 0，當迴圈跑完後再把 count_hash 物件賦予到 categoryWithCount 變數上 123456789101112131415getCategoryWithCount: function () { let count_hash = {} for (const category of this.categories) { this.products.forEach(element =&gt; { if (element.product_type === category) { if (typeof count_hash[category] === 'undefined') { count_hash[category] = 0 } count_hash[category] = count_hash[category] + 1 } }) } this.categoryWithCount = count_hash console.log(this.categoryWithCount)}, 在把跑完迴圈後的 count_hash 物件賦予到 categoryWithCount 上。用 console.log 看一下 categoryWithCount 變數，如下圖 這樣就把所有電影類型的數量計算完成了，接下來把這些數量代到 sidebar 裡面 下圖為組件的模板，我要把數量放到 span 裡面。 思考方向是執行 function 把值代入。 12345getCount: function (item) { // console.log(item) // console.log(this.categoryWithCount[item]) return this.categoryWithCount[item]}, 用 console.log() 看一下 item ，如下圖 用 console.log() 看一下 this.categoryWithCount[item]，如下圖 把 categoryWithCount 物件裡面的數量 return 出來放到 span 標籤裡面，這樣就可以顯示該電影類型的數量了。","link":"/2021/03/22/%E9%A1%AF%E7%A4%BA%E9%A1%9E%E5%9E%8B%E7%9A%84%E6%95%B8%E9%87%8F/"},{"title":"JavaScript - this 在 具名函式 & 箭頭函式下的差異。","text":"以下示範 function &amp; arrow function 的差異。 123456789101112131415161718192021//具名函釋function test1() { console.log(this.name)}// 箭頭函式let test2 = () =&gt; console.log(this.name)window.name = '外層'const obj = { name: 'ken',}// 具名函示會看命名變數作用域下的 thistest1() // \"外層\"test1.call(obj) // \"ken\"// 箭頭函式永遠指向 windowtest2() // \"外層\"test2.call(obj) // \"外層\" 如果想改變函示內的 this 值可以用 call 方法，但從結果來看，這對箭頭函式來說是無效的。 總結:test1 具名函示的 this 會指向跟函示同層作用域下命名變數的 this 值。test2 箭頭函示的 this 會指向聲明時所在作用域下的 this 值。 codePen 參考資料尚硅谷 Web 前端 ES6 教程，涵盖 ES6-ES11","link":"/2021/03/24/this/"},{"title":"JavaScript - 箭頭函式實作","text":"當我點擊藍色區塊時會改變顏色 1&lt;div id=\"app\"&gt;&lt;/div&gt; 12345678910// 綁定 DOMlet app = document.querySelector('#app')// 綁定事件app.addEventListener('click', function () { //計時器 setTimeout(function () { this.style.background = 'red' }, 2000)}) 但是這樣的執行結果會顯示 fail 。 用 console.log 看一下，會發現 this 是指向 window 的。 而 window 是沒有 style 屬性的，所以會顯示 undefined。 要解決這樣的問題就是在計時器外層將 this 命名到一個變數上，然後在計時器內層呼叫。 為甚麼要這麼做? 用 console.log 看一下外層的 this 。 點擊前 點擊兩秒後 會發現在這一層是有 background style 屬性的。 所以計時器在執行到 self 時會呼叫到外層含有 style 的屬性的 this ，這樣就可以改變樣式了。 不過有了箭頭函式後，就不需要這麼麻煩了，因為箭頭函式會指向聲明時所在作用域下的 this 值。 123456789101112// 綁定 DOMlet app = document.querySelector('#app')// 綁定事件app.addEventListener('click', function () { // 箭頭函式是在這一層作用域下聲明的，所以會拿到這一層的 this 值 // arrow function 計時器 setTimeout(() =&gt; { this.style.background = 'red' }, 2000)}) codePen 參考資料尚硅谷 Web 前端 ES6 教程，涵盖 ES6-ES11","link":"/2021/03/25/this%E7%9A%84%E5%AF%A6%E4%BD%9C/"},{"title":"JavaScript 實作 - 滾動顯示文章","text":"功能敘述：當捲動到頁尾時，會自動讀取更多的文章。 GithubDEMO 模板主要有兩個: filter bar 跟渲染資料。 12345678910111213141516&lt;!-- search bar --&gt;&lt;div class=\"filterContainer\"&gt; &lt;input type=\"text\" id=\"filter\" class=\"filter\" placeholder=\"Filter posts\" /&gt;&lt;/div&gt;&lt;!-- 渲染內容 --&gt;&lt;div id=\"postsContainer\"&gt; &lt;!-- 渲染資料的內容使用 JavaScript 寫出來 --&gt;&lt;/div&gt;&lt;!-- 小點 --&gt;&lt;div class=\"loader\" id=\"loader\"&gt; &lt;div class=\"circle\"&gt;&lt;/div&gt; &lt;div class=\"circle\"&gt;&lt;/div&gt; &lt;div class=\"circle\"&gt;&lt;/div&gt;&lt;/div&gt; 架構完成圖 CSS 樣式可依照個人喜好來設定。 JaScript三大重點: 打 API，拿資料。 滾輪往下滑載入資料。 輸入關鍵字找到文章。 1. 將 DOM 跟 HTML 綁在一起 輸入文字會需要 filter bar 在網頁內顯示資料內容 往下滑時會出現 loading 動畫 123const filter = document.querySelector('#filter')const postContainer = document.querySelector('#postsContainer')const loading = document.querySelector('#loader') 2. 打 API 獲取資料API URL在網址後面加入 limit &amp; page，可以指定一個頁面下可以顯示多少內容，例如limit = 4 : 顯示 4 個內容page = 1 : 頁數 打 API 方法有三種: AJAX、Axios、Fetch。原作使用 fetch 是現在比較新穎的技術但還是要注意瀏覽器有沒有支援到。使用 fetch 打 API ，response 回來的資料要轉 json 格式才可以使用。轉完後再把資料 return 出來給其他函式使用。 12345678910let limit = 4 // 限制一頁顯示多少個let page = 1async function getPost() { const res = await fetch( `https://jsonplaceholder.typicode.com/posts?_limit=${limit}&amp;_page=${page}` ) const data = await res.json() return data} 3. 拿到資料後，將資料渲染出來上面模板 postsContainer 內的資料有提到要用 javascript 呈現，現在要將拿到的資料利用 ES6 字串模板的方式呈現出來。 先將拿到的資料賦予到 posts 變數裡面，再將這些資料用 forEach() 的方式放到字串模板裡面，到這資料還不會呈現出來，必須再把這些資料放到 postContainer 大 “容器” 裡面，這樣資料就會依照模板的架構跟樣式來呈現。 1234567891011121314151617181920async function showPost() { const posts = await getPost() // console.log(posts); posts.forEach((post) =&gt; { const postEl = document.createElement('div') //新增 div 標籤 postEl.classList.add('post') // div 標籤名為 post postEl.innerHTML = ` &lt;div class=\"number\"&gt;${post.id}&lt;/div&gt; &lt;div class=\"postInfo\"&gt; &lt;h2 class=\"postTitle\"&gt;${post.title}&lt;/h2&gt; &lt;p class=\"postBody\"&gt;${post.body}&lt;/p&gt; &lt;/div&gt; ` // 將這些 div 輸入到 postContainer 裡面 postContainer.appendChild(postEl) })}showPost() // 執行 4. 讓條件觸發，渲染出更多資料到目前為止資料只會呈現 “一筆” 而已，即使滾輪往下拉資料還是不會出現，這也不是我們要的功能，必須在滾輪往下拉的同時在網頁最底部會顯示小點點的動畫跟載入 “下一筆” 資料。 一筆資料有 4 個內容，就是上面設定的 let limit = 4 滾輪滾動是觸發的條件，所以要用監聽 ( addEventListener )，視窗到最底部時，會顯示 loading 效果，要判斷怎樣算是最底部就用 scrollTop、scrollHeight、clientHeight 以下參考自 MDN scrollTop : 目前是瀏覽器視窗距離元素最頂端的距離。 scrollHeight : 整個元素的總高度。 clientHeight : 元素內部包含 padding 的高度。 利用解構的方式抓取三個值，再用這三個值用來判斷是否該載入資料。 123456window.addEventListener('scroll', () =&gt; { const { scrollTop, scrollHeight, clientHeight } = document.documentElement if (scrollTop + clientHeight &gt;= scrollHeight - 5) { showLoading() }}) 觸發後顯示 loading 效果，效果 1 秒後結束，並在 0.3 秒內載入資料。 1234567891011121314function showLoading() { loading.classList.add('show') // 顯示小點CSS // 移除小點時機 setTimeout(() =&gt; { loading.classList.remove('show') // 1秒後，移除小點CSS // 增加頁面同時，0.3秒內打 API 抓新資料 setTimeout(() =&gt; { page++ showPost() }, 300) }, 1000)} 5. 輸入關鍵字顯示相關文章輸入關鍵字是觸發條件，一樣用監聽 ( addEventListener )，不過函式實在太大了，可以善用 callback function。 將 post div 裡所有的內容賦予到 posts 變數上，再用 forEach 讀取裡面的每一筆資料，再用 indexOf 判斷式，判斷輸入的值有沒有跟 posts 變數上的相符並依照書入的值顯示相關文字的文章。 123456789101112131415161718filter.addEventListener('input', filterPost)function filterPost(e) { // console.log(e.target.value); const term = e.target.value.toUpperCase() const posts = document.querySelectorAll('.post') posts.forEach((post) =&gt; { const title = post.querySelector('.postTitle').innerText.toUpperCase() const body = post.querySelector('.postBody').innerText.toUpperCase() if (title.indexOf(term) &gt; -1 || body.indexOf(term) &gt; -1) { post.style.display = 'flex' } else { post.style.display = 'none' } })} 參考資料Element.clientHeightElement.scrollHeightElement.scrollTopString.prototype.toUpperCase()20 Web Projects With Vanilla JavaScript","link":"/2021/01/26/Infinite_scroll_blog/"},{"title":"JavaScript - 陣列的進階方法","text":"前言這幾天在練習寫作品集的時候發現幾個 JavaScrip 蠻常用的陣列語法，所以決定來寫一篇關於這些語法的文章。 Array.prototype.map()map(item, index, arry) : 透過函式處理陣列中每個元素，最後會回傳出一個新的陣列，如果沒有回傳就是 undefine。 函式內要傳入三個參數 : 第一個參數是要帶入的每個元素 ( 必填 )。 第二個參數是帶入值的索引值 ( 選填 )。 第三個參數是帶入的陣列 ( 選填 )。 map 進階寫法1234567let people = ['ken', 'Bob', 'Marry']let result = people.map(function (man) { return 'userName : ' + man})console.log(result) 但如果把第 4 行註解掉，就會出現下圖，因為沒有回傳任何值。 Data structure 寫法123456789101112let people = ['ken', 'Bob', 'Marry']function mapA(people) { let result = [] for (let i = 0; i &lt; people.length; i++) { // console.log(people[i]) //確認 people[i] 有抓到 let str = 'userName : ' + people[i] // console.log(str) //確認 str 有被賦值 result.push(str) } return result} 輸入 mapA(people) 如下圖，結果是一樣的 如果剛接觸 JavaScript 的話還是建議用資料結構相關的寫法，訓練基本功。 DEMO Array.prototype.forEach()forEach(item, index, arry) : 會將陣列中每個元素套用到指定的函式裡進行運算。 函式內要傳入三個參數 : 第一個參數表示每個元素的值 ( 必填 )。 第二個參數為該元素的索引值 ( 選填 )。 第三個參數則表示原本的陣列 ( 選填 )。 map &amp; forEach 進階寫法的差異forEach 跟 map 的差別在於 forEach 不會回傳出新的值，map 會回傳並產生新的陣列。 1234567891011let people = ['ken', 'Bob', 'Marry']//forEachlet forEachResult = people.forEach(function (man) { return 'userName : ' + man})//maplet mapResult = people.map(function (man) { return 'userName : ' + man}) 在 console.log 輸入 forEachResult 會得到 undefined ，在 mapResult 會得到 return 的回傳值顯示結過如下 forEach &amp; Data structure 兩種寫法123456789101112// forEachlet forEachResult = people.forEach(function (man) { console.log('userName : ' + man)})// Data structurefor (let i = 0; i &lt; people.length; i++) { // console.log(people[i]) //確認 people[i] 有抓到 let str = 'userName : ' + people[i] // console.log(str) //確認 str 有被賦值 console.log(str)} 用 console.log 查看，如下圖 DEMO Array.prototype.filter()filter() : 將陣列中的「每一個」元素帶入指定的函式內做判斷，如果元素符合判斷條件，就回傳並產生新的陣列。 filter 進階寫法給一個新的陣列，塞選出大於 5 的數，如下 12345let a = [1, 2, 3, 4, 5, 6, 7, 8]let result = a.filter(function (e) { return e &gt; 5}) 在 console.log 輸入 result ，顯示下圖 或是限制區間，要記得括號，不然 return 會認不出來 123let result = a.filter(function (e) { return e &gt; 2 &amp;&amp; e &lt; 6}) 會顯示下圖 DEMO Array.prototype.find()find() : 將陣列中的「每一個」元素帶入指定的函式內做判斷，只會傳第一個符合判斷條件的元素，如果沒有元素符合則會回傳 undefined。 filter 是回傳所有符合條件的元素，但 find 只會傳第一個符合判斷條件的元素 1234567891011let a = [1, 2, 3, 3, 3, 3]// findlet resultFind = a.find(function (e) { return e &gt; 2})// filterlet resultFilter = a.filter(function (e) { return e &gt; 2}) 分別在 console.log 輸入兩個參數，顯示如下圖 可以看到，輸入 :resultFind 只會回傳符合條件的第一個，resultFilter 會回傳所有符合條件的值同時產生新的陣列。 DEMO 參考資料JavaScript Array 陣列操作方法大全 ( 含 ES6 )JS 語言基礎 06 陣列的進階方法","link":"/2021/01/19/JS%E9%80%B2%E9%9A%8E/"},{"title":"JavaScript - Cookie、LocalStorage、SessionStorage 的差異跟使用","text":"前言利用 Javascript 將資料存到瀏覽器裡面，但是因為 http request 的關係，瀏覽器並不會知道上一個跟目前的使用者是誰，這時候就需要把使用者的資料帶到後端 sever 上。 例如我在 A 電腦開啟購物網頁選購商品並存取選購的商品資料但是在 B 電腦開啟同樣的網頁但是卻沒有剛才在 A 電腦選購的資料，這是因為資料是存在自己本地的瀏覽器裡面而不是存在後端的 sever 上，如果是存在後台的 sever 上，那不管我使用哪一台點腦，都可以開啟我在 A 電腦上選購的資料。 接下來就要介紹瀏覽器是如何存取資料的。 Cookie介紹Cookie 本身非常小，只有 4k 所以載入速度很快，瀏覽器也會記錄使用者的資料，最多可以記錄 300 多個 Cookie，但一個網站最多只能記錄 20 個左右的 Cookie 。那 Cookie 是透過 Set-Cookie header response 給客戶端的瀏覽器，每當我們開啟瀏覽器發出 request 時， sever 端都會自動把該網站 (domain) 的 Cookie 自動載入。 用途通常都會被使用在登入頁面的狀態、購物網站的選購資訊或是追蹤客戶的廣告上。 特點 大小只有 4Kb 左右 紀錄使用者的個資 每當瀏覽器發出 request 都會自動載入該使用的資料 將資料存在客戶端 只能在該網站 (domain) 內開啟 可以設定關閉瀏覽器後失效的時間 Set-Cookie header如果要讓無狀態的 http 知道客戶目前的狀態，就要用 Set-Cookie 把使用紀錄存到 Cookie 裡面，這樣下次在別的瀏覽器上向同個網站 (domain) 的 sever 發出 request 的時候，Request Headers 就可以透過 sever 查看 Cookie 的內容同時確認目前客戶的狀態。 Set-Cookie 寫法如下: 1Set-Cookie: key = value 瀏覽器會依照 Set-Cookie 設定的內容建立 key 跟 value。之後當瀏覽器發出 request 的時候，就會自動載入 key 跟 value。 Cookie 屬性除了 Set-Cookie 外，還有其他要知道的屬性。 domain : Cookie 一定要在同個網站 (domain)，下輸入使用者資料，不可能拿 A 網站的 Cookie ，用在 B 網站上。 path : 只能讀取到指定路徑下的 Cookie，如果要讓整個網站都能讀取到就寫 path = / 。 Max-Age : 設定有效期限，單位為秒，設定的數字是正值時才有效，負值時為本次 session 有效，寫 0 就是刪除 Cookie。 Expires : 一樣是設定有效時間，但在 HTTP 1.1 之後已經被 max-age 取代。 secure : 當這個屬性被設為 true 時， Cookie 只能在安全的協議 (https) 中傳送。 Create a Cookie在 JavaScript 裡面，一次只能建立一個 Cookie ，語法如下: 12document.cookie = newCookie// newCookie 指的就是 key = value 當一個 cookie 沒有設定失效時間，就是 session cookie ，該 cookie 會在使用者關閉瀏覽器後被自動刪除。 1234567// 設定兩個 cookie 叫 one, two// 在瀏覽器關閉後會自動被刪除document.cookie = 'one=cookieOne'document.cookie = 'two=cookieTwo'// 設定一個 age cookie 裡面的值是 22，儲存一分鐘document.cookie = 'age=22; max-age=60; path=/' Read a Cookie document.cookie 用來讀取 cookie，但讀取出來是一個很長的字串，字串裡面是所有曾經儲存的 cookie，格式是 key=value，用分號 ; 分隔不同的 cookie。來自 JavaScript Cookie Change a Cookie直接建立新的同名 cookie 覆蓋掉即可。 Delete a Cookie設定一個過期的時間即可。 localStorage介紹 LocalStorage 是 HTML5 提供給網頁的儲存庫，一樣只能在同個網站 (domain) 上使用，但是他不會跟 Cookie 一樣從 sever 端提取資料，資料只會存在客戶的 local 端，即使把瀏覽器關閉資料還是會存在除非使用了清除的 API，不然資料是不會消失的。 舉個例子 : 我們在逛博客來書店的時候，只要點擊某本書，最下面有個最近瀏覽紀錄就會顯是我剛才選的書籍資訊，即使關掉網頁，剛才所點選的書籍資料也還是會存在。 那 localStorage 要注意的地方是他只接受字串 (string) 型別，所以在寫入的時候 key 跟 value 要記得轉換!! 特點 大小 5Mb 左右 沒有過期時間，除非手動刪除，就算刷新頁面資料還是在 Storage 只會存在客戶端的瀏覽器上 使用 key、value 的方式給值或取值 搭配使用的 API12345678JSON.parse()JSON.string()setItem(key, value)getItem(key)removeItem(key)clear() setItem、getItem、clear API 的應用當我們要資料存到 localStorage 裡面就要用 setItem 設定 key 跟 value 值，設定好後就可以用 getItem 去抓。 12345678910// 型別是字串let str = 'ken'// localStorage.setItem('key', value)// 設定 setItemlocalStorage.setItem('userName', str)// 取值 getItemlocalStorage.getItem(str)console.log(localStorage.getItem('userName')) 如過查看發現 localStorage 有其他資訊請先打開 clear() 清掉，再執行一次。(要記得關掉 clear DEMO 接下來加入輸入框，在點擊 button 按鈕的時候會跳出輸入框裡面的值，在把值輸入到 localStorage 裡面。 12345&lt;form&gt; &lt;label for=\"name\"&gt;Name:&lt;/label&gt; &lt;input type=\"text\" class=\"name\" /&gt; &lt;input type=\"button\" value=\"點擊\" class=\"btn\" /&gt;&lt;/form&gt; 12345678let btn = document.querySelector('.btn')function saveName() { let str = document.querySelector('.name').value localStorage.setItem('userName', str)}btn.addEventListener('click', saveName) 到目前為止我還沒輸入任何東西，如下圖 但是當我在輸入框輸入 ken ，輸入框的資料就會進入到 localStorage，如下圖 目前只是將資料輸入，現在要將資料取出，那要取出就要用 getItem() 的 API 。 在 html 多加一行 1&lt;input type=\"button\" value=\"取出\" class=\"btnCall\" /&gt; 在 JS 加入 getItem function (第 11 行) 123456789101112131415161718// localStorage.clear()let btn = document.querySelector('.btn')let call = document.querySelector('.btnCall')//setItemfunction saveName() { let str = document.querySelector('.name').value localStorage.setItem('userName', str)}//getItemfunction callName() { let getStr = localStorage.getItem('userName') alert(getStr)}btn.addEventListener('click', saveName) //setItemcall.addEventListener('click', callName) //getItem 輸入，尚未點擊 點擊後 點取出，跳出 alert 視窗 注意!! 目前都是字串型別。分別在 saveName、callName 裡面加入 console.log 查看，如下圖 DEMO JSON.parse、JSON.string API 的應用JSON.parse() 的做用是將 localStorage 的 key 跟 value 值轉成物件型別，轉換型別後會變成物件或是陣列，這樣在抓取資料的時候就會比較方便，以下來示範為麼要使用 JSON.parse() 我先給一個陣列 在用 setItem 設定 key &amp; value 值 用 getItem 抓取設定好的 key 值 用 console.log 查看 123456789101112// 給個陣列let arrCount = [{ userName: 'ken' }, { age: '22' }, { gender: 'male' }]// 用 setItem 的把 key 、 value 值設定好localStorage.setItem('arrCountItem', arrCount)// 把設定好的值用 getItem 抓取，在賦直到 getArrCount 變數裡面let getArrCount = localStorage.getItem('arrCountItem')console.log(getArrCount)console.log(getArrCount[0].userName) 顯示的結果如下圖 可以看到用 setItem() 設定的 value 值 localStorage 完全看不懂 ，要讓 localStorage 看得懂 value 值就必須是字串型別!!! 用 console.log 看，也確定有抓到但卻顯示未定義，用 typeof 看一下型別，如下圖 透過上面這張圖就可以知道用 getItem() 抓到的是字串 (string) 型別並非是陣列，因為不管是陣列還是物件只要經過 localStorage 取出來的值都會變成字串 (string) 型別。然後第 16 行又用陣列的方式取值，所以會顯示 undefine 是正常的。 懶人包 :進入 localStorage 之前必須要轉成字串型別 (JSON.string)，取值的時候要轉成物件型別 (JSON.parse)。 以下示範正確方法: 將陣列轉成字串型別 確認抓到的是字串不是物件型別 用 setItem 把 key &amp; value 值設定到 localStorage 裡面 再用 getItem 把 key 轉成物件並賦值到 getArrCount 變數裡面 再將 getArrCount 轉成物件型別 12345678910111213141516171819let arrCount = [{ userName: 'ken' }, { age: '22' }, { gender: 'male' }]// 將陣列轉成字串型別let arrCountString = JSON.stringify(arrCount)// 確認抓到的是字串不是物件型別console.log(arrCountString)// 用 setItem 把 key &amp; value 值設定到 localStorage 裡面localStorage.setItem('arrCountItem', arrCountString)// 抓取 localStorage 的值，再用 getItem 把 key 轉成物件並賦值到 getArrCount 變數裡面let getArrCount = localStorage.getItem('arrCountItem')// 再將 getArrCount 轉成物件型別let arrCountArry = JSON.parse(getArrCount)console.log(arrCountArry)console.log(arrCountArry[0].userName)console.log(typeof arrCountArry) 這樣 localStorage 就可以正常賦值，而我們也可以從 localStorage 取值，顯示如下圖 DEMO SessionStorage介紹跟 localStorage 一樣，差別在於只要將瀏覽器關掉資料就會被清除，也不會跟 sever 拿資料，資料是存在客戶本地端。 特點 資料只會存在目前單一分頁裡，開新的分頁後資料是不會傳到另一個分頁裡的 當瀏覽器關掉後，資料就會被清除 Cookie、LocalStorage、SessionStorage 縮圖: 圖片來源: [JavaScript] Cookie、LocalStorage、SessionStorage 差異 參考資料JavaScript CookieDay20 localStorage、sessionStorageDay19 要來塊餅乾嗎? Cookie &amp; Session[JavaScript] Cookie、LocalStorage、SessionStorage 差異Day20-網頁儲存！Web storage[第七週] 瀏覽器資料儲存 - Cookie、LocalStorage、SessionStorage27. [WEB] Cookie &amp; Session 是什麼？[教學] 什麼是 Cookie？如何用 JS 讀取/修改 document.cookie?[JavaScript] Cookie、LocalStorage、SessionStorage 三種差異JavaScript 入門篇 - 學徒的試煉","link":"/2021/01/18/JavaScript%20-%20Cookie%E3%80%81LocalStorage%E3%80%81Sessi/"},{"title":"JavaScript 實作 - 音樂播放器","text":"功能描述: 點擊進度條可以選擇播放時段 撥放完後自動撥放下一曲 可選擇上一曲或下一曲 GithubDEMO 模板給個容器，將內容包在裡面，方便控制容器內的通用樣式跟監聽 1&lt;div class=\"music-container\" id=\"music-container\"&gt;&lt;/div&gt; 撥放音樂的時候顯示音樂名稱跟進度條 123456&lt;div class=\"music-info\"&gt; &lt;h4 id=\"title\"&gt;&lt;/h4&gt; &lt;div class=\"progress-container\" id=\"progress-container\"&gt; &lt;div class=\"progress\" id=\"progress\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 撥放歌曲 1&lt;audio src=\"music/ukulele.mp3\" id=\"audio\"&gt;&lt;/audio&gt; 音樂圖片 123&lt;div class=\"img-container\"&gt; &lt;img src=\"images/ukulele.jpg\" alt=\"music-cover\" id=\"cover\" /&gt;&lt;/div&gt; 音樂撥放按鈕，按鈕使用是 Font Awesome 顯示 1234567891011121314&lt;div class=\"navigation\"&gt; &lt;button id=\"prev\" class=\"action-btn\"&gt; //上一首 &lt;i class=\"fas fa-backward\"&gt;&lt;/i&gt; &lt;/button&gt; &lt;button id=\"play\" class=\"action-btn action-btn-big\"&gt; //暫停或是撥放 &lt;i class=\"fas fa-play\"&gt;&lt;/i&gt; &lt;/button&gt; &lt;button id=\"next\" class=\"action-btn\"&gt; //下一首 &lt;i class=\"fas fa-forward\"&gt;&lt;/i&gt; &lt;/button&gt;&lt;/div&gt; 完成圖 樣式樣式可以依照個人喜好來設定。因為案例中在撥放音樂的時候，音樂圖片會像 CD 被讀取一樣一直旋轉，所以這裡介紹一下 CSS 的動畫效果 ( animation )。 @keyframes : 動畫影格，控制 CSS 從哪移動到哪的概念。 在這案例中撥放音樂的時候會圖片會旋轉，旋轉就會用 rotate 來控制旋轉角度，再用 deg 為單位。 123456789@keyframes rotate { from { transform: rotate(0deg); //從甚麼角度開始 } to { transform: rotate(360deg); //到什麼角度 }} CSS 動畫還有其他屬性可以使用。以下圖片來自 : 完整解析 CSS 動畫 ( CSS Animation ) JavaScript1. 抓取 DOM 元素123456789const musicContainer = document.querySelector('#music-container')const progressContainer = document.querySelector('#progress-container')const progress = document.querySelector('#progress')const audio = document.querySelector('#audio')const cover = document.querySelector('#cover')const PrevBtn = document.querySelector('#prev')const playBtn = document.querySelector('#play')const nextBtn = document.querySelector('#next')const title = document.querySelector('#title') 2. 撥放音樂的時候要顯示的歌曲名稱跟圖片1234567891011const songs = ['hey', 'summer', 'ukulele']let songsIndex = 2loadSong(songs[songsIndex])function loadSong(song) { title.innerText = song audio.src = `music/${song}.mp3` cover.src = `images/${song}.jpg`} 3. 撥放跟暫停監聽撥放跟暫停按鈕，再把這動作寫成 callback function。在撥放音樂的時候要在 musicContainer DOM 上面加上 classList play ，才會產生動畫效果同時 icon 也會變更，撥放時是暫停的 icon ，暫停時是撥放的 icon 。 123456789101112131415161718192021222324function playSong() { musicContainer.classList.add('play') playBtn.querySelector('i.fas').classList.remove('fa-play') playBtn.querySelector('i.fas').classList.add('fa-pause') audio.play()}function pauseSong() { musicContainer.classList.remove('play') playBtn.querySelector('i.fas').classList.add('fa-play') playBtn.querySelector('i.fas').classList.remove('fa-pause') audio.pause()}playBtn.addEventListener('click', () =&gt; { const isPlaying = musicContainer.classList.contains('play') if (isPlaying) { pauseSong() } else { playSong() }}) 4. 切換歌曲利用陣列的數量跟索引值決定下一首，但陣列中的索引值最小是 0，如果一直按上一首歌曲，到索引值 0 的時候就會卡住了，不會從最後面的歌曲開始往回推，所以要用函式判斷，當小於歌曲陣列的索引值時，要從陣列的最後一個索引開始往回推。 上一首判斷式中 songs.length - 1 是因為陣列內長度是 3 ，但索引值是 2 ，所以3 - 1 會回到歌曲索引值的 2 也就是最後一首，這樣一直按上一首的話就可以變成無窮迴圈了 下一首同理，如果點擊的數字大於陣列中的索引值 ( 最後一首歌 )，那就讓陣列回索引值為 0 的第一首歌曲開始。 1234567891011121314151617181920212223242526function preSong() { songsIndex-- if (songsIndex &lt; 0) { songsIndex = songs.length - 1 } loadSong(songs[songsIndex]) playSong()}function nextSong() { songsIndex++ if (songsIndex &gt; songs.length - 1) { songsIndex = 0 } loadSong(songs[songsIndex]) playSong()}PrevBtn.addEventListener('click', preSong)nextBtn.addEventListener('click', nextSong) 5. 顯示進度讀取條撥放音樂的時候時間軸會更新同時觸發 updateProgress function ，function 會帶出 progress bar 讀取進度。 timeupdate : 在更新時間的時候會觸發 e.srcElement 是目前事件觸發的來源，用 console.log 查看，顯示下圖 duration : 時間的總長度 currentTime : 當下讀取的時間軸 progress 會隨著音樂時間的長度顯示 bar 條。 1234567function updateProgress(e) { const { duration, currentTime } = e.srcElement const progressPercent = (currentTime / duration) * 100 progress.style.width = `${progressPercent}%`}audio.addEventListener('timeupdate', updateProgress) 6. 指定音樂撥放的時間軸有了 progress bar 就可以利用 bar 條指定時間軸。clientWidth : 是這個元素下的總寬度。而這裡的 clientWidth 是指向 ，progress 的總寬度，如下圖 有了總寬度還需要音樂時間軸的寬度用 console.log 看 clientWidth、clickX，如下圖 當我點擊時間軸後，會跳出總長度跟該元素的長度，將這兩個元素相除的結果等於當下元素的長度，在乘上時間軸就可以把點擊當下 bar 條跟音樂時間軸同時綁定，這樣點擊時間軸會跳到該時段 bar 條也會同時顯示長度。 下圖比較能理解 offset 跟 clint 語法:上圖來源 123456789function setProgress(e) { const width = this.clientWidth const clickX = e.offsetX const duration = audio.duration audio.currentTime = (clickX / width) * duration}progressContainer.addEventListener('click', setProgress) 參考資料CSS 動畫完整解析 CSS 動畫 ( CSS Animation )Animate.cssHTMLMediaElement：timeupdate20 Web Projects With Vanilla JavaScript","link":"/2021/01/22/Music-player/"},{"title":"jQuery - 選擇器的進階 Traversal","text":"1. 選擇器的進階 Traversal(遍歷) 鄰居、爸爸與小孩遍歷示意圖:Traversal 這觀念就是透過 API 操作相鄰隔壁的元素，以下示範 1234567891011121314151617&lt;ul id=\"ul-1\"&gt; &lt;li&gt;ul-1&lt;/li&gt; &lt;li&gt;ul-1&lt;/li&gt; &lt;li&gt;ul-1&lt;/li&gt;&lt;/ul&gt;&lt;ul id=\"ul-2\"&gt; &lt;li&gt;ul-2&lt;/li&gt; &lt;li&gt;ul-2&lt;/li&gt; &lt;li&gt;ul-2&lt;/li&gt;&lt;/ul&gt;&lt;ul id=\"ul-3\"&gt; &lt;li&gt;ul-3&lt;/li&gt; &lt;li&gt;ul-3&lt;/li&gt; &lt;li&gt;ul-3&lt;/li&gt;&lt;/ul&gt; 原圖如下: 接下來套用 jQuery 三步驟，讓 dom 變色 123$('document').ready(function(){ $('#ul-1').css('color', 'red')}) 確定可以變色後，接下來要使用 Traversal 的效果，而這效果的 API 是 siblings 123$('document').ready(function(){ $('#ul-1').siblings().css('color', 'red')}) 會顯示下圖，自己不變動，周圍的變動 也可以透過鄰居再做其他動作，如下 1234$('document').ready(function(){ $('#ul-1').siblings().first().css('color', 'red')}) 抓取鄰居的第一個，顯示如下 除了這方法還可以用陣列的方式抓取，但是如果用陣列的話會變成純元素，所以外面還是要用 $() ，將 $('#ul-1').siblings().[1] 包起來，由於在 js 陣列裡面第一個索引都是從 0 開始算，所以如果寫 [1] 就會顯示第二個，如下圖 123$('document').ready(function(){ $($('#ul-1').siblings().[1]).css('color', 'red')}) DEMO 2. 鍊式( Chaining )寫法jQuery 的鍊式( Chaining )寫法。就是 API 可以依照需求一直接下去。 利用上面的範例在各 ul 外再加上父層 .ul-father ，注意! 是 className 不是 id 1234567891011121314151617181920212223&lt;div class='ul-father'&gt; &lt;ul id=\"ul-1\"&gt; &lt;li&gt;ul-1&lt;/li&gt; &lt;li&gt;ul-1&lt;/li&gt; &lt;li&gt;ul-1&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class='ul-father'&gt; &lt;ul id=\"ul-2\"&gt; &lt;li&gt;ul-2&lt;/li&gt; &lt;li&gt;ul-2&lt;/li&gt; &lt;li&gt;ul-2&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class='ul-father'&gt; &lt;ul id=\"ul-3\"&gt; &lt;li&gt;ul-3&lt;/li&gt; &lt;li&gt;ul-3&lt;/li&gt; &lt;li&gt;ul-3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 樣式排版一下如下圖 假設我們要讓 ul-3 的第一個變紅色的話，可以先透過父層的 .ul-father 再找到子層的第一個元素，這會用到練式寫法下 找到父層中的最後一個 12345$('document').ready(function(){ $('.ul-father') .last() .css('color', 'red')}) 用 .children() 進到子層裡面，這時已經到 ul 層了 123456$('document').ready(function(){ $('.ul-father') .last() .children() .css('color', 'red')}) 再用 .children() 進到 li 層 12345678$('document').ready(function(){ $('.ul-father') .last() .children() .children() .css('color', 'red')}) 再用 .first() 選 li 裡面的第一個 元素 123456789$('document').ready(function(){ $('.ul-father') .last() .children() .children() .first() .css('color', 'red')}) DEMO以上就是鍊式寫法的示範 ~ 3. Traversing 中的 first(), last(), find()以下示範是為了練習，方法很多種，這裡單純練習 API 的使用。在 jquery 中利用 first() 找到指定的元素，以下示範 1234567891011121314151617181920212223242526&lt;div id='ul-father-2'&gt; &lt;div class='ul-father'&gt; &lt;ul id=\"ul-1\"&gt; &lt;li&gt;ul-1&lt;/li&gt; &lt;li&gt;ul-1&lt;/li&gt; &lt;li&gt;ul-1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class='ul-father'&gt; &lt;ul id=\"ul-2\"&gt; &lt;li&gt;ul-2&lt;/li&gt; &lt;li&gt;ul-2&lt;/li&gt; &lt;li&gt;ul-2&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class='ul-father'&gt; &lt;ul id=\"ul-3\"&gt; &lt;li&gt;ul-3&lt;/li&gt; &lt;li&gt;ul-3&lt;/li&gt; &lt;li&gt;ul-3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; first()透過用 className 的方式讓 ul-1 亮紅色，因為相同的 className 有三個所以會選到其他的元素，這時就可以用 first()，來指定我們只要選第一個就好，以下示範 1234// 第一個顯示顏色$(document).ready(function(){ $('.ul-father').first().css('color', 'red')}) last()同理，換成最後一個就是 last() 1234// 最後一個個顯示紅色$(document).ready(function(){ $('.ul-father').last().css('color', 'red')}) find()在 ul-father 外再加一層父層，然後稍為更改一下 HTML 結構。 1234567891011121314151617181920212223&lt;div id='ul-father-2'&gt; &lt;div class='ul-father'&gt; &lt;ul id=\"ul-1\"&gt; &lt;li&gt;ul-1&lt;/li&gt; &lt;li&gt;ul-1&lt;/li&gt; &lt;li&gt;ul-1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class='ul-father'&gt; &lt;ul id=\"ul-2\"&gt; &lt;li&gt;ul-2&lt;/li&gt; &lt;li&gt;ul-2&lt;/li&gt; &lt;li&gt;ul-2&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class='ul-father'&gt; &lt;ul id=\"ul-3\"&gt; &lt;li&gt;ul-3&lt;/li&gt; &lt;li&gt;ul-3&lt;/li&gt; &lt;li&gt;ul-3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 將所有 ul-father 移到 ul-father-2 裡面，如果想要改變 ul-1 裡面的 li 元素就可以用 find() 123$(document).ready(function(){ $('#ul-father-2').find('#ul-1').css('color', 'red')}) 這樣就可以抓到ul-1 並更改樣式了~ DEMO 4. Traversal 中的 eq(), filter() 與 not()以下示範單純為了練習 api 而使用。 eq()eq() 就是等於，功能類似指定 1234567891011&lt;div class=\"a\"&gt;A&lt;/div&gt;&lt;div class=\"a\"&gt;A&lt;/div&gt;&lt;div class=\"a\"&gt;A&lt;/div&gt;&lt;div class=\"b\"&gt;B&lt;/div&gt;&lt;div class=\"b\"&gt;B&lt;/div&gt;&lt;div class=\"b\"&gt;B&lt;/div&gt;&lt;div class=\"c\"&gt;C&lt;/div&gt;&lt;div class=\"c\"&gt;C&lt;/div&gt;&lt;div class=\"c\"&gt;C&lt;/div&gt; 把 B 變紅色 $('.b').css('color', 'red') 但如果只要第一個 B 變紅色的話就加上 eq()，完整寫法 $('.b').eq('0').css('color', 'red')，要注意的是 jquery 的 API 還是用陣列的芳來指定索引，在陣列中第一個索引是 0，但還是要以官方文件為主。 filter()filter() 就是塞選在 HTML 結構下方加入 &lt;span class='a'&gt;this is span&lt;/span&gt;， className 設定為 a，如果單純寫 $('.a').css('color', 'red') 這樣會抓到所有 className 為 a 的元素，如下圖 這時候就可以用 filter()，來指定 span 標籤，$('.a').filter('span').css('color', 'red')這樣就只會更改用 span 的標籤 not()概念就是除了誰以外，其他都可以，例如除了 .a 以外的其他都更改樣式$('div').not('.a').css('color', 'red')，這樣除了 .a 的以外其他就都更改到樣式了 DEMO 參考資料jQuery 幼幼班","link":"/2021/01/15/Traversal/"},{"title":"用 Vue 做出頁面的 Loading 效果","text":"vue-loading-overlay首先安裝 npm: npm install vue-loading-overlay再到 main.js 載入 1234567// Import componentimport Loading from 'vue-loading-overlay';// Import stylesheetimport 'vue-loading-overlay/dist/vue-loading.css';// 因為是全域每個 component 都會用，所以用 Vue.componentVue.component('Loading', Loading) 全域Loading接下來要在 components 裡面加入讀取的判斷式跟綁定先將 lading 預設好，只有在等待的時間下才會轉 isLoading: false, 然後把範例拿過來用 在div 內一層加上 &lt;loading :active.sync=\"isLoading\"&gt;&lt;/loading&gt; 接下來要在 AJAX 的行為上面新增 isLoading: false,在啟用 getProducts 的時候就會觸發 loading ( true )，在完成的時候結束( false )範例如下: 12345678getProducts() { const api = `${process.env.APIPATH}/api/${process.env.MYPATH}/products` this.isLoading = true this.$http.get(api).then((response) =&gt; { this.products = response.data.products this.isLoading = false })}, 然後再重新整理，畫面中間就會出現 Loading 的效果，再試試按下編輯或是新增然後直接按下確認也會有 Loading 的效果 這樣全域就完成了!! 局部 Loading再來要做局部的，我們要在新增或是編輯圖片那邊加上 loading 的效果 要加的地方在下圖紅框處 這邊偷懶一下直接用 CDN 載入 font-awesome 到 index.html 然後再到 Animating Icons 選一個自己喜歡的 loading 樣式這邊用 fa-spinner fa-spin 作範例因為要在上傳圖片的旁邊顯示 laoding 效果，所以我們把 fa-spinner fa-spin 加在 label 旁邊， 再到 data 函式加入決定局部 loading 的變數 再到模板那邊用 v-if 判斷做動態綁定 然後在上傳圖片的函示( uploadImg )內加入局部 loading 判斷 12345678910111213141516171819202122232425uploadImg() { // 在拉圖片進去讀取的時候 fileUpLoading 會是 true this.status.fileUpLoading = true const uploadFile = this.$refs.files.files[0] const formData = new FormData() formData.append('file-to-upload', uploadFile) //接下來定義路徑 const url = `${process.env.APIPATH}/api/${process.env.MYPATH}/admin/upload` this.$http .post(url, formData, { headers: { 'Content-Type': 'multipart/form-data' } }) .then((res) =&gt; { console.log(res.data) // AJAX 結束後 fileUpLoading 就 false this.status.fileUpLoading = false if (res.data.success) { // this.tempProduct.imgUrl = res.data.imageUrl console.log(this.tempProduct) this.$set(this.tempProduct, 'imgUrl', res.data.imageUrl) } })} 資料來源: Vue 出電商網站","link":"/2020/12/13/Loading/"},{"title":"Vue - 組件化 ( 一 )","text":"簡介面對複雜問題的處裡的方式就是將問題分割，而將東西分割的方式在 Vue 裡面我們稱為組件化。 大概 10 年前吧，原本一個網頁是由一個 HTML、CSS、JavaScript 所組成的，但這樣在改動某個地方的時候會非常麻煩也會擔心會不會影響到網頁其他地方。後來出現了用 JavaScript 寫成的前端框架，將網頁內部切分成很多區塊，讓這些區塊內都有獨立的 HTML、CSS、JavaScript，這樣當某個區塊改動時就不必擔心會影響到網頁內的其他區塊，也因為每個區塊都是獨立的所以重複利用，這也讓開發者大大的提升了開發效率。 下圖來自官網 組件化的思想就是盡可能的把頁面拆分成很多個小區塊，變成可重複利用的組件。 組件化開發1.組件化的基本使用在之前基本模板語法提到用 mustache 語法可以顯示 data 物件內的 value 值，但如果有非常多重複的內容，這樣做不只可讀性差，也不好維護。用以下程式碼來示範。 12345678910111213&lt;div id=\"app\"&gt; &lt;h2&gt;{{message1}}&lt;/h2&gt; &lt;p&gt;{{message2}}&lt;/p&gt; &lt;h2&gt;{{message1}}&lt;/h2&gt; &lt;p&gt;{{message2}}&lt;/p&gt; &lt;h2&gt;{{message1}}&lt;/h2&gt; &lt;p&gt;{{message2}}&lt;/p&gt; &lt;h2&gt;{{message1}}&lt;/h2&gt; &lt;p&gt;{{message2}}&lt;/p&gt;&lt;/div&gt; 1234567const app = new Vue({ el: '#app', data: { message1: 'title', message2: 'hello world', },}) 顯示下圖 這樣寫確實會顯示 4 個內容，但一樣的內容要寫 4 次才會呈現，而且有很冗長，這時就可以用組件的方式撰寫，可讀性也比較高。 以下示範如何組件化。 分成三大步驟: 創造組件構造器 : Vue.extend() 註冊組件 : Vue.component() 使用組件 : Vue 實例的使用範圍 首先把重複性高的拉出來，如下圖，紅框處的重複性特別高，所以要獨立出來變成組件。 1. 創造組件在 Vue.extend 組件裡面，它有個屬性是 template ，就是模板，在模板裡面的所有內容都是獨立且可重複利用的，把上圖紅框處放到模板裡面。再把 Vue.extend() 賦予到 vm 變數裡面，用變數是為了方便待會在註冊 ( component ) 的時候呼叫。 123456789// 1. 創造組件const vm = Vue.extend({ template: ` &lt;div&gt; &lt;h2&gt;我是模板的:title&lt;/h2&gt; &lt;p&gt;我是模板的:hello world&lt;/p&gt; &lt;/div&gt; `,}) 2. 註冊組件創造完要註冊，它需要兩個參數，第一個參數是 模板的標籤名稱 可以自訂義，第二個是 創造組件的變數 就是指上面的 vm ，寫法也非常簡單，如下 123// 2.註冊組件Vue.component('模板的標籤名稱', 創造組件的變數)Vue.component('my-cpn', vm) 完整寫法: 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;h2&gt;{{message1}}&lt;/h2&gt; &lt;p&gt;{{message2}}&lt;/p&gt; &lt;!-- &lt;h2&gt;{{message1}}&lt;/h2&gt; &lt;p&gt;{{message2}}&lt;/p&gt; &lt;h2&gt;{{message1}}&lt;/h2&gt; &lt;p&gt;{{message2}}&lt;/p&gt; &lt;h2&gt;{{message1}}&lt;/h2&gt; &lt;p&gt;{{message2}}&lt;/p&gt; --&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt; 123456789101112131415161718192021// 1. 創造組件const vm = Vue.extend({ template: ` &lt;div&gt; &lt;h2&gt;我是模板的:title&lt;/h2&gt; &lt;p&gt;我是模板的:hello world&lt;/p&gt; &lt;/div&gt; `,})// 2.註冊組件Vue.component('my-cpn', vm)// 3.使用組件const app = new Vue({ el: '#app', data: { message1: 'title', message2: 'hello world', },}) 顯示下圖 會發現在 html 上只要寫 my-cpn 標籤就可以顯示相同的內容，這就是組件化，之後如果想改動 html 的內容只要針對組件內的內容做改動就好，這樣不只增加可讀性同時也方便管理。 但要特別注意的是模板標籤必須寫在 id='app' 標籤裡面，寫在外面是不會被使用到的。 DEMO Vue.extend() 在 Vue2.X 版以後就沒看到了，會示範也是因為這是必要的基礎觀念，之後的開發上就不會使用 Vue.extend() 而是使用語法糖的方式撰寫。 2. 全域組件跟區域組件以上所寫的都是全域組件，全域就是可以在多個 Vue 實例裡面使用。之前所寫的 Vue 實例只有一個，那可不可有兩個?答案是 : 可以的! 但真實開發只會有一個，以下是為了釐清觀念所示範的。 再新增一個 Vue 實例 ( id='app2' ) 1234567&lt;div id=\"app\"&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;div id=\"app2\"&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt; 12345678910111213141516171819202122// 1. 創造組件const vm = Vue.extend({ template: ` &lt;div&gt; &lt;h2&gt;我是模板的:title&lt;/h2&gt; &lt;p&gt;我是模板的:hello world&lt;/p&gt; &lt;/div&gt; `,})// 2.註冊組件Vue.component('my-cpn', vm)// 3.使用組件const app = new Vue({ el: '#app',})// 新增一個實例 app2const app2 = new Vue({ el: '#app2',}) 一樣可以使用，如下圖 用開發模式看，會看到 app2 也有用到全域組件 那要怎麼做才會變成區域組件?方法很簡單，就是把 Vue.component('my-cpn', vm) 移到 Vue 實例裡面 ( 記得 component 要加 s )。Vue 實例裡面新增 components 一個屬性，再給 components 屬性一個物件，裡面放 key 跟 value 值。 key 值指的是自訂義模板的標籤名， value 就是組件的變數名稱。 要特別注意的是 key 值的寫法，跟 HTML 模板標籤的寫法。key 值的寫法分兩種: 單字以減號-分離 ( Kebab Case ) 必須加引號。 駝峰式命名法 ( Camel Case )，加不加引號都可以。 HTML 模板的組件標籤必須是 Kebab Case 寫法。 1234567891011const app = new Vue({ el:'#app', components:{ // Kebab Case 'my-cpn': vm // Camel Case myCpn: vm 'myCpn': vm }}) 以下示範區域組件 1234567&lt;div id=\"app\"&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;div id=\"app2\"&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526// 1. 創造組件const vm = Vue.extend({ template: ` &lt;div&gt; &lt;h2&gt;我是模板的:title&lt;/h2&gt; &lt;p&gt;我是模板的:hello world&lt;/p&gt; &lt;/div&gt; `,})// 2.註冊組件// Vue.component('my-cpn', vm)// 3.使用組件const app = new Vue({ el: '#app', components: { // 'my-cpn': vm // 'myCpn': vm myCpn: vm, },})const app2 = new Vue({ el: '#app2',}) 用開發者工具看，app 有在實例裡面註冊，所以可以使用，但 app2 不能，因為沒有在 app2 裡面註冊，所以不會解析 my-cpn 標籤。 DEMO 以上就是區域組件的示範，在實戰開發上也是區域組件使用的最多，也只會有一個 Vue 實例。 3. 父子組件顧名思義就是組件裡面再放一層組件。 以下範例是創造一個 vm2 組件，再把 vm1 放到 vm2 裡面註冊，再到 Vue 實例裡面註冊 vm2。 123&lt;div id=\"app\"&gt; &lt;my-cpn2&gt;&lt;/my-cpn2&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233// 1. 創造組件 vm1const vm1 = Vue.extend({ template: ` &lt;div&gt; &lt;h2&gt;One&lt;/h2&gt; &lt;p&gt;One&lt;/p&gt; &lt;/div&gt; `,})// 創造組件 vm2const vm2 = Vue.extend({ template: ` &lt;div&gt; &lt;h2&gt;Two&lt;/h2&gt; &lt;p&gt;Two Content&lt;/p&gt; &lt;my-cpn1&gt;&lt;/my-cpn1&gt; &lt;/div&gt; `, // 註冊組件 vm1 components: { 'my-cpn1': vm1, },})// 3.使用組件const app = new Vue({ el: '#app', // 2.註冊組件 components: { 'my-cpn2': vm2, },}) 結果為下圖 用開發者工具查看 由上面案例可知 vm2 為父組件，vm1 為子組件。 當 HTML 再解析 my-cpn2 標籤的內容時，他會到 vm2 裡面解析模板的內容，而解析 vm2 模板的內容時又發現 my-cpn1 標籤，這時他會看看有沒有註冊 my-cpn1 的標籤，如果有找到它就會對應到 vm1 模板的內的內容，如果 vm1 裡面沒找到的話，它就會去全域組件找，如果全域還找不到就會報錯。 編譯好之後的模板如下 1234567891011121314151617181920212223242526// 創造組件 vm2const vm2 = Vue.extend({ template: ` &lt;div&gt; &lt;h2&gt;Two&lt;/h2&gt; &lt;p&gt;Two Content&lt;/p&gt; &lt;div&gt; &lt;h2&gt;One&lt;/h2&gt; &lt;p&gt;One&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; `, components: { 'my-cpn1': vm1, },})// 3.使用組件const app = new Vue({ el: '#app', // 2.註冊組件 components: { 'my-cpn2': vm2, },}) 換個角度來說 Vue 實例也是一個父組件，只差沒寫 template 屬性。 DEMO 4. 註冊組件的語法糖 以上當我們再創造組件的時候所使用的 Vue.extend() 在 Vue 2.X 以後已經很少用了幾乎是不會再出現。 一開始先用 extend 創造，再用 component 註冊。 123&lt;div id=\"app\"&gt; &lt;my-cpn1&gt;&lt;/my-cpn1&gt;&lt;/div&gt; 1234567891011121314151617// 1. 創造組件const vm1 = Vue.extend({ template: ` &lt;div&gt; &lt;h2&gt;One&lt;/h2&gt; &lt;p&gt;One&lt;/p&gt; &lt;/div&gt; `,})// 2.註冊組件Vue.component('my-cpn1', vm1)// 3.使用組件const app = new Vue({ el: '#app',}) 但我們可以把上面 Vue.extend 裡面的內容移到 Vue.component 裡面，如下 123456789// 把 vm1 改成 extend 創造的物件Vue.component('my-cpn1', { template: ` &lt;div&gt; &lt;h2&gt;One&lt;/h2&gt; &lt;p&gt;One&lt;/p&gt; &lt;/div&gt; `,}) 同理，可以在把 Vue.component 的內容移到 Vue 實例裡面，但 component 要記得加 s ，所以又可以再改寫一次，如下 1234567891011121314// 3.使用組件const app = new Vue({ el: '#app', components: { 'my-cpn1': { template: ` &lt;div&gt; &lt;h2&gt;One&lt;/h2&gt; &lt;p&gt;One&lt;/p&gt; &lt;/div&gt; `, }, },}) 這就是組件化的語法糖的最終版。 要特別注意的是除了 component 要加 s ， 逗號也要改成冒號。 DEMO 5. 組件模板的分離寫法在上一點註冊組件的語法糖中，最終寫法是將模板的資料寫到 Vue 實例裡面，但模板其實是可以寫到 HTML 裡面的，以下要講解的是比較簡單的分離寫法。 script 標籤，屬性為 type='text/x-template'在 HTML 裡面創造 script 標籤，加上 type='text/x-template' 跟 一個 id ，id 是為了在註冊裡面綁定用的，寫法如下。 但要特別注意的是，在 模板裡面要記得加上 div 標籤。 1234567891011&lt;div id=\"app\"&gt; &lt;my-cpn1&gt;&lt;/my-cpn1&gt;&lt;/div&gt;&lt;!-- 在這裡創造一個模板 --&gt;&lt;script type=\"text/x-template\" id=\"vm1\"&gt; &lt;div&gt; &lt;h2&gt;title&lt;/h2&gt; &lt;p&gt;content&lt;/p&gt; &lt;/div&gt;&lt;/script&gt; 123456789// 註冊 vm1 組件Vue.component('my-cpn1', { template: '#vm1',})// 使用組件const app = new Vue({ el: '#app',}) 顯示下圖 template 標籤template 寫法會更好記，因為只需要寫 template 加上 id 就好。 1234567891011&lt;div id=\"app\"&gt; &lt;my-cpn1&gt;&lt;/my-cpn1&gt;&lt;/div&gt;&lt;!-- template 寫法 --&gt;&lt;template id=\"vm1\"&gt; &lt;div&gt; &lt;h2&gt;title&lt;/h2&gt; &lt;p&gt;content&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; Vue 實例跟上面一樣。 123456789// 註冊組件Vue.component('my-cpn1', { template: '#vm1',})// 使用組件const app = new Vue({ el: '#app',}) 顯示效果跟上面一樣。 以上就是模板的分離寫法。 DEMO 參考資料2019 年最全最新 Vue、Vuejs 教程，从入门到精通","link":"/2021/02/28/Vue%20%E7%B5%84%E4%BB%B6%E4%B8%80/"},{"title":"Vue - data 必須是函數","text":"介紹在上一篇 Vue 組件化 ( 一 ) 介紹了組件話的觀念跟應用，但沒提到組件化的資料必須要用動態綁定來確保資料的獨立，所以這篇就來介紹一下組件化的 data 。 Data 必須是函式因為每個組件都會有自己的模板，每個模板都會有自己的樣式或是邏輯，為了讓組件之間的資料不互相影響，必須將資料以函式的方式撰寫。上一篇文章中提到的組件化，在模板內我都是直接寫值，並沒有用 mustache 語法來做動態綁定，因為當時還沒將 data 變成函數資料有可能不會呈現，但是在子組件下的 data 若是以函數的形式呈現，就不用擔心這問題，也可以確保每個組件的資料是獨立的。 拿之前寫的組件範例示範 12345678910111213&lt;div id=\"app\"&gt; &lt;my-cpn1&gt;&lt;/my-cpn1&gt;&lt;/div&gt;&lt;!-- template 寫法 --&gt;&lt;template id=\"vm1\"&gt; &lt;div&gt; &lt;h2&gt;title&lt;/h2&gt; //資料寫死 &lt;p&gt;content&lt;/p&gt; //資料寫死 &lt;/div&gt;&lt;/template&gt; 123456789// 註冊組件Vue.component('my-cpn1', { template: '#vm1',})// 3.使用組件const app = new Vue({ el: '#app',}) 在 template 模板裡面的資料，是寫死狀態，那改用 mustache 語法的話，會怎麼樣? 只改動 template 模板內容 123456&lt;template id=\"vm1\"&gt; &lt;div&gt; &lt;h2&gt;{{title}}&lt;/h2&gt; &lt;p&gt;content&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 在 Vue 實例裡面新增 data 物件 123456const app = new Vue({ el: '#app', data: { title: '我是標題', },}) 用開發者工具看會報錯，也提示 title 沒有被定義 這是因為組件內部是不能讀取 Vue 實例裡面的資料。而子組件裡面有屬於自己的 HTML 模板，也應該有屬於自己的資料。 所以把上面組件內的 data 改成用函數的方式回傳，寫法也很簡單，template 內容一樣，只要在子組件裡面新增 data 函數的屬性並 return 物件內的值就好。 12345678Vue.component('my-cpn1', { template: '#vm1', data() { return { title: '我是組件內的標題', } },}) 結果為下圖 同樣道理，在把上式改寫成計數器的話 12345678910111213&lt;div id=\"app\"&gt; &lt;my-cpn1&gt;&lt;/my-cpn1&gt; &lt;my-cpn1&gt;&lt;/my-cpn1&gt; &lt;my-cpn1&gt;&lt;/my-cpn1&gt;&lt;/div&gt;&lt;!-- template 寫法 --&gt;&lt;template id=\"vm1\"&gt; &lt;div&gt; &lt;h2&gt;{{count}}&lt;/h2&gt; &lt;button @click=\"count++\"&gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 12345678Vue.component('my-cpn1', { template: '#vm1', data() { return { count: 0, } },}) 組件內的每筆資料也都是互相獨立的 DEMO 總結:在 Vue 實例裡面，data 是物件。在子組件裡面 data 必須以函數的方式回傳物件。 參考資料子元件的 data 必須是函數2019 年最全最新 Vue、Vuejs 教程，从入门到精通","link":"/2021/02/28/Vue-data/"},{"title":"Vue - 基本語法( 三 )","text":"用 v-if、v-show 的條件判斷決定選染的內容。 條件判斷這指令可以根據表達式的值來判斷是否在 DOM 中渲染或是銷毀元素/組件。 寫法也很簡單，就跟 JavaScript 的 if 判斷式一樣。 1. v-if在 DOM 標籤中加入 v-if 判斷式來決定要不要顯示，該標籤內的內容。 123&lt;div id=\"app\"&gt; &lt;h2 v-if=\"true\"&gt;{{message}}&lt;/h2&gt;&lt;/div&gt; 123456const app = new Vue({ el: '#app', data: { message: 'Hello World', },}) 顯示下圖v-if 後面都是接一個布林值。為了可以動態顯示將寫法改寫一下，將 true 改成一個變數。這樣就可以透過發發者工具來控制要不要顯示。 1234&lt;div id=\"app\"&gt; &lt;!-- &lt;h2 v-if='true'&gt;{{message}}&lt;/h2&gt; --&gt; &lt;h2 v-if=\"isShow\"&gt;{{message}}&lt;/h2&gt;&lt;/div&gt; 1234567const app = new Vue({ el: '#app', data: { message: 'Hello World', isShow: true, },}) 改成 false 交看不到內容 改成 true 後又會顯示出來。 DEMO 2. v-if &amp; v-elsev-if 很好理解，在 true 的狀況下就會顯示，在 false 的狀況下會顯示 v-else 內的內容。 1234&lt;div id=\"app\"&gt; &lt;h2 v-if=\"isShow\"&gt;{{message}}&lt;/h2&gt; &lt;h2 v-else&gt;{{elseMessage}}&lt;/h2&gt;&lt;/div&gt; 12345678const app = new Vue({ el: '#app', data: { message: 'Hello World', elseMessage: '我是 v-else', isShow: true, },}) 原本是 v-if 判斷為 true 的狀況下顯示 Hello World 那如過改成 false 就會顯示 v-else 的內容，如下圖 DEMO 3. v-if 、 v-else-if &amp; v-else這寫法也很簡單，我們用分數來決定顯示的內容。 12345&lt;div id=\"app\"&gt; &lt;h2 v-if=\"score &gt;= 90\"&gt;大於90分以上，頂標&lt;/h2&gt; &lt;h2 v-else-if=\"score &gt;= 60 &amp;&amp; score &lt;= 89\"&gt;介於60分以上，89分以下，均標&lt;/h2&gt; &lt;h2 v-else=\"score &lt;= 59 \"&gt;低於59分以下，低標&lt;/h2&gt;&lt;/div&gt; 123456const app = new Vue({ el: '#app', data: { score: 90, },}) 因為 score 預設是 90 ，所以會顯示頂標 如果我把分數改成 80，顯示下圖 再把分數改成 50，顯示下圖最後一次寫的是app.score = 50 所以會被覆蓋掉上面 80 分的 DEMO 4. computed 寫法除了以上寫法還可以靈活使用上一篇文章提到的計算屬性 computed，如果只是 v-if、v-else 的話沒什麼關係，但如果有很多計算的話比較推薦使用 computed 寫法同時可以增強閱讀性。 1234567&lt;div id=\"app\"&gt; &lt;h2 v-if=\"score &gt;= 90\"&gt;大於90分以上，頂標&lt;/h2&gt; &lt;h2 v-else-if=\"score &gt;= 60 &amp;&amp; score &lt;= 89\"&gt;介於60分以上，89分以下，均標&lt;/h2&gt; &lt;h2 v-else=\"score &lt;= 59 \"&gt;低於59分以下，低標&lt;/h2&gt; &lt;h2&gt;computed : {{finalScore}}&lt;/h2&gt;&lt;/div&gt; 12345678910111213141516171819const app = new Vue({ el: '#app', data: { score: 90, }, computed: { finalScore() { let showMessage = '' if (this.score &gt;= 90) { showMessage = '大於90分以上，頂標' } else if (this.score &gt;= 60 &amp;&amp; this.score &lt;= 89) { showMessage = '介於60分以上，89分以下，均標' } else { showMessage = '低於59分以下，低標' } return showMessage }, },}) 顯示下圖 將分數改成 80 ，顯示下圖 再改成 50，顯示下圖( 最後一次寫是 app.score = 50 所以會覆蓋掉 80 分 ) DEMO 5. 條件渲染的實作在輸入使用者資料的時候可以切換使用者類型 利用 v-if 、v-else 來判斷我要顯示的內容，在切換的時候再用 click 判斷 v-if 接收到的值是 true 還是 false。 1234567891011&lt;div id=\"app\"&gt; &lt;span v-if=\"isUser\"&gt; &lt;label for=\"username\"&gt;使用者姓名: &lt;/label&gt; &lt;input type=\"text\" id=\"username\" placeholder=\"username\" /&gt; &lt;/span&gt; &lt;span v-else&gt; &lt;label for=\"useremail\"&gt;使用者信箱: &lt;/label&gt; &lt;input type=\"mail\" id=\"email\" placeholder=\"user-email\" /&gt; &lt;/span&gt; &lt;button @click=\"isUser = !isUser\"&gt;切換類型&lt;/button&gt;&lt;/div&gt; 123456const app = new Vue({ el: '#app', data: { isUser: true, },}) 透過點擊按鈕可以切換輸入框 DEMO 6. v-showv-show 的用法也相當簡單，跟 v-if 的用法一樣，但是差別只在於 DOM 的顯示。 1234567&lt;div id=\"app\"&gt; &lt;h2 v-if=\"show\"&gt;{{vIfShow}}&lt;/h2&gt; &lt;h2 v-show=\"show\"&gt;{{vShow}}&lt;/h2&gt; &lt;button @click=\"show = !show\"&gt;切換類型&lt;/button&gt;&lt;/div&gt; 12345678const app = new Vue({ el: '#app', data: { vIfShow: 'v-if 顯示', vShow: 'v-show 顯示', show: true, },}) 用開發者工具看到對應的 DOM，兩者在 true 的狀態下都會顯示 兩者在 false 的狀態下，顯示下圖 ( 標註一下上上比較清楚 ) DMEO 結論:兩個判斷皆為 false 時 v-if 對應的 DOM 會消失。 v-show 的 DOM 不會消失，它只是用了 css 效果的 display: none。 參考資料2019 年最全最新 Vue、Vuejs 教程，从入门到精通","link":"/2021/02/24/Vue%E5%9F%BA%E6%9C%AC%E8%AA%9E%E6%B3%95(%20%E4%B8%89%20)/"},{"title":"Vue - 基本語法( 二 )","text":"在模板中可以直接使用插值語法顯示 data 中的資料，但是在某些狀況下有些資料還是要經過計算再顯示，或是多個資料結合或是重複顯示，這時候就會使用到 computed 計算屬性。 還有 v-on 監聽事件的修飾符跟實際應用。 計算屬性 ( computed )1. 計算屬性的基本使用之前有提到過 mustache 語法，可以簡單的顯示資料，如果一個資料沒什麼大礙，但有很多資料的話呢? 以下示範。 firstName 跟 LastName 如果中間想有空格，會有兩種寫法，如下。 1234&lt;div id=\"app\"&gt; &lt;h2&gt;{{firstName +' '+ LastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName}} {{LastName}}&lt;/h2&gt;&lt;/div&gt; 12345678const app = new Vue({ el: '#app', data: { message: 'Hello World', firstName: 'Lebron', LastName: 'Jamse', },}) 會顯示下圖 那如果今天要顯示 5~10 個呢? 如下 123456789&lt;div id=\"app\"&gt; &lt;h2&gt;{{firstName +' '+ LastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName}} {{LastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName}} {{LastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName}} {{LastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName}} {{LastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName}} {{LastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName}} {{LastName}}&lt;/h2&gt;&lt;/div&gt; 這樣的話太長了，如果綁定的 key 值變更的話上面就要改 5 次，如果只需要改一次的話就會比較輕鬆，這時候有兩種方法可以使用 : methods 、 computed。 ( 一 ) methods 寫法12345&lt;div id=\"app\"&gt; &lt;h2&gt;{{firstName +' '+ LastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName}} {{LastName}}&lt;/h2&gt; &lt;h2&gt;methods 寫法 : {{getFullName()}}&lt;/h2&gt;&lt;/div&gt; 上面第 4 行比第 2、3 行簡潔多了。把重複的動作寫成函式，再呼叫實例裡面的函式。 12345678910111213const app = new Vue({ el: '#app', data: { message: 'Hello World', firstName: 'Lebron', LastName: 'Jamse', }, methods: { getFullName() { return this.firstName + ' ' + this.LastName }, },}) 這樣就算 data 裡面的 key 值變更，也只要更改 methods 裡面的的 key 值，而且只改一次就全部完成。 顯示如下 DEMO 不過一般 mustache 語法裡面只通常只放變數，放函式感覺很奇怪，這時候就可以用 computed 。 ( 二 ) computed當資料裡面產生變化的時候才會執行。 12345678910&lt;div id=\"app\"&gt; &lt;h2&gt;{{firstName +' '+ LastName}}&lt;/h2&gt; &lt;h2&gt;{{firstName}} {{LastName}}&lt;/h2&gt; &lt;!-- methods 有小括號，是函式 --&gt; &lt;h2&gt;methods 寫法 : {{getFullName()}}&lt;/h2&gt; &lt;!-- computed 沒有小括號，是變數 --&gt; &lt;h2&gt;computed 寫法 : {{fullName}}&lt;/h2&gt;&lt;/div&gt; 123456789101112131415161718const app = new Vue({ el: '#app', data: { message: 'Hello World', firstName: 'Lebron', LastName: 'Jamse', }, computed: { fullName() { return this.firstName + ' ' + this.LastName }, }, methods: { getFullName() { return this.firstName + ' ' + this.LastName }, },}) 顯示如下。 methods 寫法會在 mustache 裡面加上小括號，那是一個函式，computed 寫法只會在 mustache 裡面放變數，不會有小括號。 DEMO 2. 計算屬性的複雜操作計算陣列內的總價格 123&lt;div id=\"app\"&gt; &lt;h2&gt;Total Price : {{totalPrice}}&lt;/h2&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132const app = new Vue({ el: '#app', data: { books: [ { id: 1, name: 'html、css 書籍', price: 110 }, { id: 2, name: 'JavaScript 書籍', price: 220 }, { id: 3, name: 'Vue 書籍', price: 330 }, { id: 4, name: 'React 書籍', price: 440 }, ], }, computed: { totalPrice() { let total = 0 // for( let i=0; i&lt; this.books.length; i++){ // total+= this.books[i].price // } // return total // for in 寫法 // for( let i in this.books){ // total+= this.books[i].price // } // return total // for of 寫法 for (let book of this.books) { total += book.price } return total }, },}) DEMO 3. 計算屬性的 setter &amp; getter123&lt;div id=\"app\"&gt; &lt;h2&gt;{{firstName + ' ' + lastName}}&lt;/h2&gt;&lt;/div&gt; 1234567const app = new Vue({ el: '#app', data: { firstName: 'Lebron', lastName: 'Jamse', },}) 由於用 mustache 語法寫的話太複雜了，加上如果要重複利用的話有太冗長，所以都會使用 computed 計算屬性。 12345&lt;div id=\"app\"&gt; &lt;h2&gt;{{firstName + ' ' + LastName}}&lt;/h2&gt; &lt;h2&gt;對應 computed 寫法: {{fullName}}&lt;/h2&gt;&lt;/div&gt; 123456789101112const app = new Vue({ el: '#app', data: { firstName: 'Lebron', lastName: 'Jamse', }, computed: { fullName() { return this.firstName + ' ' + this.lastName }, },}) 顯示下圖 就跟上面所寫的一樣，不過接下來要加上 get &amp; set 屬性，這才是 computed 屬性的完整寫法。 如果沒有 set 方法的話都是默認 get 方法的值，也就是只讀屬性。例如我只在 get 方法裡面返回 hello 字串。 12345678910111213141516171819// html 模板一樣const app = new Vue({ el: '#app', data: { firstName: 'Lebron', lastName: 'Jamse', }, computed: { // fullName(){ // return this.firstName+ ' '+ this.LastName // } fullName: { set() {}, get() { return 'hello' }, }, },}) 顯示下圖 一般情況下我們只會用到 get 方法，不會使用到 set 方法，因為不希望別人隨便設定一些奇怪的值，寫法如下。 123456789101112131415const app = new Vue({ el: '#app', data: { firstName: 'Lebron', lastName: 'Jamse', }, computed: { fullName: { get() { // return 'hello' return this.firstName + ' ' + this.lastName }, }, },}) 也因為一般情況下都會使用到 get 方法，所以上面的寫法會簡化成最一開始的寫法。 123456789101112131415161718192021const app = new Vue({ el: '#app', data: { firstName: 'Lebron', lastName: 'Jamse', }, computed: { fullName() { return this.firstName + ' ' + this.lastName }, // fullName:{ // set(){ // }, // get(){ // return 'hello' // return this.firstName+ ' '+ this.lastName // } // } },}) 所以當我們在使用 computed 屬性時， mustache 語法裡面就不需要家小括號，因為在使用 computed 屬性時他會去調用 computed 裡面的 get。 那如果真想要在 computed 裡面加上 set 的話也可以。在 set 方法裡面必須傳入參數。 123&lt;div id=\"app\"&gt; &lt;h2&gt;{{fullName}}&lt;/h2&gt;&lt;/div&gt; 1234567891011121314151617181920212223const app = new Vue({ el: '#app', data: { firstName: 'Lebron', lastName: 'Jamse', }, computed: { // fullName(){ // return this.firstName+ ' '+ this.LastName // } fullName: { set(newValue) { const names = newValue.split(' ') this.firstName = names[0] this.lastName = names[1] }, get() { // return 'hello' return this.firstName + ' ' + this.lastName }, }, },}) 在還沒 set 之前顯示下圖 還沒更改前是 Lebron Jamse ，用開發者工具使用更改 fullName 之後如下圖 會改變的原因是更改了 data 裡面的 firstName &amp; lastName 這兩個更改就代表 get 方法裡面的 this.firstName+ ' '+ this.lastName 也會跟著更改，那this.firstName+ ' '+ this.lastName 更改就代表 fullName 被更改了。 總結一下，90%情況下 set 方法是不會寫的所以會省略掉，那省略掉後就會有更簡潔的寫法，如下。 123456789101112const app = new Vue({ el: '#app', data: { firstName: 'Lebron', lastName: 'Jamse', }, computed: { fullName() { return this.firstName + ' ' + this.LastName }, },}) DEMO 監聽事件1. v-on監聽是前端在開發時常常用到的屬性，主要是監聽事件的發生，例如:滑鼠點擊、拖曳、鍵盤點擊…等等。 那在 Vue 當中監聽事件的語法為 v-on ，語法糖為 @。 以下示範用監聽滑鼠點擊來做一個簡單的計數器 12345&lt;div id=\"app\"&gt; &lt;h2&gt;{{count}}&lt;/h2&gt; &lt;button @click=\"add\"&gt;+&lt;/button&gt; &lt;button @click=\"minus\"&gt;-&lt;/button&gt;&lt;/div&gt; 1234567891011121314const app = new Vue({ el: '#app', data: { count: 0, }, methods: { add() { this.count++ }, minus() { this.count-- }, },}) 利用間聽 click 事件來判斷當前要做的事。當我們點擊 + 號按鈕的時候用 v- on 監聽同時綁定 add 事件，那 add 事件會綁定到 methods 裡面的函式，同理 - 號按鈕也一樣。 DEMO 以上皆為 v-on 最基本的使用。接下來要示範傳參數的問題。 2. v-on 參數問題在 methods 觸發 click 事件的時候，要注意傳參數的問題。 如果不需要另外傳參數的話，那方法後面的小括號就甭加。 如果需要傳入參數，同時又需要 event 這時就可以用 $event 傳到事件裡面。 ( 一 )事件不傳參數以下示範在沒傳參數的情況下小括號加與不加的差別。 1234&lt;div id=\"app\"&gt; &lt;button @click=\"btn1()\"&gt;按鈕1&lt;/button&gt; &lt;button @click=\"btn2\"&gt;按鈕2&lt;/button&gt;&lt;/div&gt; 123456789101112const app = new Vue({ el: '#app', data: {}, methods: { btn1() { console.log('我是按鈕1，有小括號') }, btn2() { console.log('我是按鈕2，沒有小括號') }, },}) 如下圖，結果是一樣的，所以在沒傳入參數的話一般都會省略小括號。 DEMO ( 二 ) 定義事件，模板省略的小括號，但是 methods 本身需要傳入一個參數。把按鈕 2 的參數拿掉，用 methods 傳入參數的話怎麼樣? 1234&lt;div id=\"app\"&gt; &lt;button @click=\"btn1(123)\"&gt;按鈕1&lt;/button&gt; &lt;button @click=\"btn2\"&gt;按鈕2&lt;/button&gt;&lt;/div&gt; 123456789101112const app = new Vue({ el: '#app', data: {}, methods: { btn1(abc) { console.log('我是按鈕1，有小括號', abc) }, btn2(abc) { console.log('我是按鈕2，沒有小括號', abc) }, },}) 如下圖，用開發者工具看 log 點擊 按鈕 1 會正常出現，但是 按鈕 2 要用瀏覽器的開發者工具查看 會回傳 MouseEvent ，就是回傳瀏覽器的 event ，因為 Vue 會把默認瀏覽器產生的 event 事件當作參數傳到函式裡面。 所以按鈕 2 的參數要寫 event 不是 abc 。 DEMO ( 三 ) 定義函式時，需要傳入參數跟 event123&lt;div id=\"app\"&gt; &lt;button @click=\"btn1(123, event)\"&gt;按鈕1&lt;/button&gt;&lt;/div&gt; 123456789const app = new Vue({ el: '#app', data: {}, methods: { btn1(abc, event) { console.log('我是按鈕1，有小括號', abc, event) }, },}) 不過傳入的第一個參數是數字型別，如果改成 abc 的話就會報錯，如下圖 因為改成 abc 後第一個參數就是變數了，所以他會去 data 裡面找 value 值 1234&lt;div id=\"app\"&gt; &lt;!-- &lt;button @click='btn1(123, $event)'&gt;按鈕1&lt;/button&gt; --&gt; &lt;button @click=\"btn1(abc, $event)\"&gt;按鈕1&lt;/button&gt;&lt;/div&gt; 在 data 裡面添加 abc 的 value 值。 1234567891011const app = new Vue({ el: '#app', data: { abc: '第一個參數變成變數了', }, methods: { btn1(abc, event) { console.log('我是按鈕1，傳入兩個參數', abc, event) }, },}) 這樣就可以正常顯示了。同理第一個參數改成字串，那他就會顯示字串! DEMO 3. v-on 修飾符在 JavaScript 裡面，都會監聽一些事件，例如 submit但是我們都會用 event.preventDefault() 來阻擋事件冒泡，同理 v-on 也可以。寫法也較為簡單: event.stopPropagation() 會寫成 .stop event.preventDefault() 會寫成 .prevent 只觸發一次 .once 只監聽特定按鍵，如: @keyup.enter 、 @keyup.按鍵碼 參考資料2019 年最全最新 Vue、Vuejs 教程，从入门到精通[筆記][JavaScript]所謂的「停止事件」到底是怎麼一回事？","link":"/2021/02/23/Vue%E5%9F%BA%E6%9C%AC%E8%AA%9E%E6%B3%952/"},{"title":"Vue - 組件的使用","text":"Vue 組件是預先定義好的模組，包含 html 的視覺元素、綁定的資料跟偵聽器..等等，類似 Vue 實例，組件的好處是可以重複使用，在開發上可以只專注在一小區塊，維護也很方便 Vue.component 前面會先傳入參數的名稱，後面的參數是 option ，option 是用模板 template 定義視覺元素，也直接在模板裡面去定義內容，舉例 : 在模板裡面定義 html 的內容 ( hello world ) ，然後在 html 裡面定義 #app 並在裡面放入 my-component 標籤，而 my-component 並非是 html 標籤，是我在 Vue.component 定義好的。 Vue.component 有個特別的規範，就是前面的參數要全小寫並加上「 - 」分開，請養成習慣!，同時 Vue.component 的宣告必須在 new Vue 之前 1234567891011121314&lt;div id=\"app\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;!-- 此為 Global 的 component --&gt;&lt;script&gt; Vue.component('my-component', { template: '&lt;div&gt;hello world&lt;/div&gt;', }) new Vue({ el: '#app', })&lt;/script&gt; 此範例是全域都可以使用的codePen 除了全域( Global )宣告以外還有 local 的宣告，它只會存在 Vue 實例裡面 1234567891011121314&lt;div id=\"app\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', components: { 'my-component': { template: '&lt;div&gt;hello world&lt;/div&gt;', }, }, })&lt;/script&gt; 在 new Vue 裡面給一個屬性 components ，屬性的 key 是字串 key my-component 也是組件名稱codePen 但是 local 有缺點，就是如果我宣告兩個 div ，但只會顯示一個 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;div id=\"app2\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', components: { 'my-component': { template: '&lt;div&gt;hello world&lt;/div&gt;', }, }, }) new Vue({ el: '#app2', })&lt;/script&gt; 它只會顯示一個 div 那用 Global 宣告就不會有這問題 1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;div id=\"app2\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', { template: '&lt;div&gt;hello world&lt;/div&gt;', }) new Vue({ el: '#app', }) new Vue({ el: '#app2', })&lt;/script&gt; 這樣就會有兩個實例codePen 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/09/06/Vue%E7%B5%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"在 Windows 上安裝 WSL1","text":"為了在 window 作業系統上執行 linux ，所以會需要安裝 WSLWSL 又有分1 跟 2，1 的話較為簡單，以下只示範 WSL1 安裝 WSL1依照官網的手動安裝步驟用系統管理員身分開啟 PowerShell 並輸入:dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 如下圖 然後再依照說明跳到步驟6，到 Microsoft Store 搜尋 Ubuntu ，這邊選用 18.04 LTS 的版本 或是點選下面附上的連結也可以安裝好後再開啟 Ubuntu 18.04 LTS 如果開啟後看到以下訊息也不要慌張~這代表我還未安裝 Windows 子系統 12345Installing, this may take a few minutes...WslRegisterDistribution failed with error: 0x8007019eThe Windows Subsystem for Linux optional component is not enabled. Please enable it and try again.See https://aka.ms/wslinstall for details.Press any key to continue... 解決方法:用系統管理員開啟 PowerShell ，並輸入以下指令Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 這邊請不要急著按!!! 請先把該存檔的資料存檔在按 Y ，因為電腦會直接重新開機 重開後會顯示要輸入使用者名字跟密碼注意! 請不要輸入特殊字元，不然會叫你重新輸入輸入密碼時會有第二次確認，而且螢幕不會顯示出來，所以請慢慢輸入~完成後會顯示下圖: WSL2WSL2 官網有特別說明，若要更新至 WSL 2，必須是 Windows 10，除此之外組建編號必須是 18362.1049+ 或 18363.1049+這兩種版本 確認 window 10 的版本號，確認方法是:按住 Windows + R 然後在對話方塊，接著輸入「winver」就會出現下圖 因我的組建編號不符，故不更新 參考資料Windows 10 上適用於 Linux 的 Windows 子系統安裝指南win10自带Bash安装的坑（Error Code: 0x8007019e，0x8000000D）撰寫 Hexo 文章 - Markdown 語法大全","link":"/2020/12/17/WSL/"},{"title":"OWASP ZAP 網頁測試","text":"ZAP 網頁滲透工具ZAP 測試分兩種方法: GUI 介面測試跟 Docker 測試到官網下載 Cross Platform Package 測試程式(此版本為 2.9.0) GUI 介面測試開啟 GUI 前要先安裝 jdk-8u271-windows-x64，否則無法開啟， 安裝好後將 Cross Platform Package 資料夾內 ZAP_2.9.0 檔開啟 第一次開啟會問是否要將 session 存起來圖片來源: EPH 的程式日記 開啟後要先設定 report 的儲存位置，這裡示範在桌面創建資料(report)夾並將檔名命名為 test 設定 ok 後，按下 Save 接下來左上角可以設定測試模式(這邊選用標準模式示範)，右邊視窗選擇掃描模式(這邊用自動掃描) 選擇自動掃描後，在將要測試的網址寫入 按下 Attack ，下面區塊就開始掃描了 測試完成，左邊旗子的顏色就是威脅的等級，以下測出我們有一個中威脅跟三個低威脅(威脅等級分成高中低還有訊息，高威脅的旗子會是紅色的，中威脅的旗子是橘色，低威脅的旗子是黃色) 點開其中一個威脅，右邊視窗會跳出(由上而下)威脅等級、問題描述、解法跟可以參考的資料 然後再依照這些提示訊息加以修正 以上是使用 GUI 介面測試的示範 Docker ZAP 測試此測法較為詳細，ZAP Docker Documentation掃描方法分成兩種 開啟虛擬機BIOS 開啟方法因為要使用 docker 就要到 BIOS 開啟虛擬機，回到桌面開啟工作管理員/效能，確認虛擬機是否有開啟，如下圖 安裝環境Docker 官網下載 docker 安裝 安裝好 docker 後，會要求重新開機 接下來要用 cmd 測試，指令可參考 ZAP Docker User Guide有穩定版跟每周更新版，這邊示範穩定版開啟 cmd 安裝 docker zap: docker pull owasp/zap2docker-stable 等大概 5~10 分鐘，安裝好後如下圖 這樣就可以開始測試了 Baseline ScanZAP Docker Documentation 如果只是單純測試的話可以參考官方給的範例:docker run -t owasp/zap2docker-stable zap-baseline.py -t https://www.example.com 由於專案關係要將測試結果做成 report 並存到指定位置，所以將指令改寫成如下:docker run -v C:\\Users\\ken.tseng\\Desktop\\zap:/zap/wrk/ -t owasp/zap2docker-stable zap-baseline.py -t https://xxxxxx.com/ -w report_md 將指令輸入並打開 docker ，確認是否有在 run前面測試大概會花 5~10 分鐘左右，只要 docker 顯示 RUNNING 就代表有在 Run 以下為測結果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970PASS: Cookie No HttpOnly Flag [10010]PASS: Cookie Without Secure Flag [10011]PASS: Cross-Domain JavaScript Source File Inclusion [10017]PASS: Content-Type Header Missing [10019]PASS: X-Frame-Options Header [10020]PASS: Information Disclosure - Debug Error Messages [10023]PASS: Information Disclosure - Sensitive Information in URL [10024]PASS: Information Disclosure - Sensitive Information in HTTP Referrer Header [10025]PASS: HTTP Parameter Override [10026]PASS: Information Disclosure - Suspicious Comments [10027]PASS: Open Redirect [10028]PASS: Cookie Poisoning [10029]PASS: User Controllable Charset [10030]PASS: User Controllable HTML Element Attribute (Potential XSS) [10031]PASS: Viewstate [10032]PASS: Directory Browsing [10033]PASS: Heartbleed OpenSSL Vulnerability (Indicative) [10034]PASS: X-Backend-Server Header Information Leak [10039]PASS: Secure Pages Include Mixed Content [10040]PASS: HTTP to HTTPS Insecure Transition in Form Post [10041]PASS: HTTPS to HTTP Insecure Transition in Form Post [10042]PASS: User Controllable JavaScript Event (XSS) [10043]PASS: Big Redirect Detected (Potential Sensitive Information Leak) [10044]PASS: Retrieved from Cache [10050]PASS: X-ChromeLogger-Data (XCOLD) Header Information Leak [10052]PASS: Cookie Without SameSite Attribute [10054]PASS: X-Debug-Token Information Leak [10056]PASS: Username Hash Found [10057]PASS: X-AspNet-Version Response Header [10061]PASS: PII Disclosure [10062]PASS: Timestamp Disclosure [10096]PASS: Hash Disclosure [10097]PASS: Cross-Domain Misconfiguration [10098]PASS: Weak Authentication Method [10105]PASS: Reverse Tabnabbing [10108]PASS: Modern Web Application [10109]PASS: Absence of Anti-CSRF Tokens [10202]PASS: Private IP Disclosure [2]PASS: Session ID in URL Rewrite [3]PASS: Script Passive Scan Rules [50001]PASS: Insecure JSF ViewState [90001]PASS: Charset Mismatch [90011]PASS: Application Error Disclosure [90022]PASS: Loosely Scoped Cookie [90033]WARN-NEW: Incomplete or No Cache-control and Pragma HTTP Header Set [10015] x 1 https://xxxxxx.com/ (200 OK)WARN-NEW: X-Content-Type-Options Header Missing [10021] x 2 https://xxxxxx.com/ (200 OK) https://xxxxxx.com/favicon.ico (200 OK)WARN-NEW: Strict-Transport-Security Header Not Set [10035] x 4 https://xxxxxx.com/ (200 OK) https://xxxxxx.com/robots.txt (404 Not Found) https://xxxxxx.com/sitemap.xml (404 Not Found) https://xxxxxx.com/favicon.ico (200 OK)WARN-NEW: Server Leaks Version Information via \"Server\" HTTP Response Header Field [10036] x 4 https://xxxxxx.com/ (200 OK) https://xxxxxx.com/robots.txt (404 Not Found) https://xxxxxx.com/sitemap.xml (404 Not Found) https://xxxxxx.com/favicon.ico (200 OK)WARN-NEW: Server Leaks Information via \"X-Powered-By\" HTTP Response Header Field(s) [10037] x 4 https://xxxxxx.com/ (200 OK) https://xxxxxx.com/robots.txt (404 Not Found) https://xxxxxx.com/sitemap.xml (404 Not Found) https://xxxxxx.com/favicon.ico (200 OK)WARN-NEW: Content Security Policy (CSP) Header Not Set [10038] x 1 https://xxxxxx.com/ (200 OK)WARN-NEW: CSP: Wildcard Directive [10055] x 2 https://xxxxxx.com/robots.txt (404 Not Found) https://xxxxxx.com/sitemap.xml (404 Not Found)FAIL-NEW: 0 FAIL-INPROG: 0 WARN-NEW: 7 WARN-INPROG: 0 INFO: 0 IGNORE: 0PASS: 44 測出結果有 7 項 WARN-NEW ，後面顯示有問題的項目提示，WARN-NEW 下面顯示的是有問題的 URL 有哪些，詳細的弱點描述跟解法資訊請看 report 參考資料官方文件用 OWASP ZAP 做滲透測試，找尋網站可能的弱點EPH 的程式日記","link":"/2020/12/15/ZAP/"},{"title":"JavaScript 實作 - 簡易版匯率轉換","text":"功能敘述：切換匯率計算各國的匯率。 GithubDemo 1. 用 JS 撰寫利用選擇器抓取 DOM 元素123456const currencyElOne = document.querySelector('#currencyOne')const currencyElTwo = document.querySelector('#currencyTwo')const amountElOne = document.querySelector('#amountOne')const amountElTwo = document.querySelector('#amountTwo')const swapEl = document.querySelector('#swap')const rateEl = document.querySelector('#rate') 監聽抓取 dom 的操作事件，同時綁定事件的操作12345// 監聽 DOM 狀態currencyElOne.addEventListener('change', caclulate)currencyElTwo.addEventListener('change', caclulate)amountElOne.addEventListener('input', caclulate)amountElTwo.addEventListener('input', caclulate) 事件操作API這邊要注意的是 Fetch API 的方式，在打完 API ，response 資料的時候，雖然資料已經是 JSON 格式，但 Fetch 必須再轉一次 JSON，變成 json promise，否則是抓不到後端回傳的資料的。參考文章 123456789101112131415161718192021222324// 操作 DOM 同時執行運算function caclulate() { // 透過選取的 DOM 將該 DOM的值塞到新變數中 const currencyOne = currencyElOne.value const currencyTwo = currencyElTwo.value // 發送 request ，開始打 API fetch(`https://api.exchangerate-api.com/v4/latest/${currencyOne}`) // 後端傳送 response 回傳結果 .then((res) =&gt; res.json()) //將回傳結果轉換成 json 格式 .then((data) =&gt; { // console.log(data) // 用陣列的方式抓去 keyValue，再將值塞到 rate 變數中 const rate = data.rates[currencyTwo] // console.log(rate) //將計算後的值放到綁定的 rate dom 中，同時計算當前匯率 rateEl.innerHTML = `1 ${currencyOne} = ${rate} ${currencyTwo}` // 幣值2的值 = 幣值1的值*匯率，將值四捨五入 amountElTwo.value = (amountElOne.value * rate).toFixed(2) })} 切換匯率，將匯率互相對調這邊要注意的是，必須要先將currencyElOne.value 塞到 temp 變數中，方便待會賦值，會這樣做是有原因的 以下列這段程式碼為例，分別用 console.log 查看值 12345678910111213swapEl.addEventListener('click', function () { const temp = currencyElOne.value currencyElOne.value = currencyElTwo.value console.log('currencyElOne.value', currencyElOne.value) currencyElTwo.value = currencyElOne.value console.log('currencyElTwo.value', currencyElTwo.value) // currencyElTwo.value = temp // console.log('temp', temp) caclulate()}) 結果如下圖 兩個轉換的匯率都會長一樣，而且匯率永遠都會卡 1，無法轉換，如下圖 為防止這樣的情況發生，可以先將 currencyElOne.value 塞到 temp 中，再確認 temp 值的是否有抓到，如下圖 然後再將 temp 賦予到currencyElTwo.value，這樣就可以避免匯率卡 1 的問題，最後要記得執行計算。 完整函式如下 123456swapEl.addEventListener('click', function () { const temp = currencyElOne.value currencyElOne.value = currencyElTwo.value currencyElTwo.value = temp caclulate()}) 2. 用 jQuery 撰寫抓取 DOM ，同時綁定事件先將每個 DOM 事件切割成一小部分，撰寫方法也要為簡單，步驟如下: 抓取 DOM 元素 $('#currencyOne') 後面再接事件change， 事件裡面會包發生的動作 caclulate() 執行 caclulate() 12345678910111213141516171819202122// 將 dom 切割成小事件// 監聽 currencyOne 選取值$('#currencyOne').change(function () { caclulate()})// 監聽 amountOne 選取值$('#amountOne').change(function () { caclulate()})// 監聽 currencyTwo 選取值$('#currencyTwo').change(function () { caclulate()})// 監聽 amountTwo 選取值$('#amountTwo').change(function () { caclulate()})caclulate() 事件裡面會包發生的動作這邊示範用 jquery ajax 打 api 1234567891011121314151617181920212223242526// 變動容器內的 dom，同時計算匯率function caclulate() { // 用 jquery 的方式命名變數 let currencyOne = $('#currencyOne').val() let currencyTwo = $('#currencyTwo').val() let rate = $('#rate').val() // 用 ajax 打 api $.ajax({ methods: 'GET', url: `https://api.exchangerate-api.com/v4/latest/${currencyOne}`, }) // 後端 respose 資料，將資料用 res 命名 .done(function (res) { // 可用 console.log(res) 查看 response api // 將後端的資料塞到 rate 裡面，[currencyTwo] 是抓取物件 keyValue let rate = res.rates[currencyTwo] // 用 console.log(rate) 查看是否有抓到 keyValue // 將匯率轉換後的值塞到 amountTwo dom 裡面，並4捨5入取到第2位 $('#amountTwo').val(($('#amountOne').val() * rate).toFixed(2)) // 將轉換的匯率顯示在各匯率之間 $('#rate').text(`1 ${currencyOne} = ${currencyTwo} * ${rate}`) })} 動作的匯率對調函式邏輯跟上面 js 的一樣，差別寫法上會有些微的不同 1234567// 按下 swap dom 會將匯率對調$('#swap').click(function () { let temp = $('#currencyOne').val() $('#currencyOne').val($('#currencyTwo').val()) $('#currencyTwo').val(temp) caclulate()}) 參考資料:JavaScript Fetch API 使用教學20 Web Projects With Vanilla JavaScript","link":"/2021/01/08/changeRate/"},{"title":"JavaScript - var 、 let 、 const 的差別","text":"前言每當我們在命名變數的時候，都會有作用域上的困擾，或是不熟悉 var 、 let 、 const 三者之間的差別，導致環境中的變數被互相汙染，甚至影響到全域變數，為釐清這當中的觀念，決定寫一篇文章來幫助自己，方便日後回憶。 var 的宣告 var = variable 的縮寫 當我們用 var 宣告變數並賦值後，如果後面又用相同的變數同樣又被賦值，那後面的值會覆蓋掉前面的值，如下 12345var name = 'ken'var name = 'kevin'console.log(name) 變數同樣設為 name ，但卻顯示後面的值。 那如果用大括號包起來呢 ?( 這邊用大括號是為了待會的 let 宣告比較，所埋下的伏筆 ) 1234567var name = 'ken'{ var name = 'kevin'}console.log(name) 結果還是一樣的。 再輸入 window.name 查看，發現全域上已經有 name 的值了。 其實在宣告一個變數的時候，並不是故意要覆蓋掉之前的值，但有時候就這麼的剛好命名到相同的變數名稱。 用 var 宣告就等於是全域 ( window ) 的宣告，這是 var 的一個缺點，為防止這樣的事發生，我們可以用 function 包起來，防止變數互相汙染。 以下示範用 function 控制 var 的作用域1. 只在立即函式裡面宣告 var在 function 裡面用 var 宣告變數後，分別在 function 裡面跟外面用 console.log 查看 123456;(function () { var functionName = 'kevin' console.log('我是 function 裡面的 ' + functionName)})()console.log('外面的' + functionName) 顯示下圖 再用 window.functionName 查看，會顯示 undefined，就代表 var 會被限制在 function 裡面，不會汙染到外面的相同變數。 2. 在立即函式裡、外同時宣告 var如果不信脫離函式會汙染到全域或是其他變數的話，那在立即函式外面在用 var 宣告相同變數，但不同值，然後再用 window.functionName 查看全域變數。 1234567;(function () { var functionName = 'kevin' console.log('我是 function 裡面的 ' + functionName)})()var functionName = 'ken'console.log('外面的' + functionName) 由上圖可知，如果 var 脫離了立即函式或是任何函示就會不受控制的污染其他相同變數，甚至是全域變數。 DEMO 雖然有了 function 可以防止 var 宣告的變數汙染到其他變數，但除了 function 以外的 for loop 、if else 判斷式也會有不受控制的問題，以下示範 for loop用 var 宣告條件，在 scope 裡面跟外面都加上 console.log。 1234for (var i = 0; i &lt; 5; i++) { console.log('裡面的 i = ' + i)}console.log('我是外面的 i = ' + i) 外面會顯示 5 是因為最後還會跑一次 i++此時 i = 5 ，不符合 i &lt; 5 所以跳出 for loop if else12345if (true) { var name = 'ken' console.log(name)}console.log(name) DEMO 如果想一次防止變數遭受汙染或是不受控制的話，可以使用下一節要說的 let 宣告。 let 的宣告 let 沒有縮寫 上一段提到，如果用 var 宣告的話會不受控制或是汙染到其他變數，不過在 ES6 語法裡面，是有方法可以解決這問題的，就是 let 宣告。 那 let 跟 var 的差別在於作用域 { }。 剛才兩個變數都是用 var 來做宣告，後面若再用一樣的變數，那變數的值是可以被覆蓋的，但是在 let 宣告下是禁止的，let 只能遠許一個相同名稱的變數存在，以下示範 1234567let letName = 'ken'{ let letName = 'kevin'}console.log(letName) 會顯示 Uncaught SyntaxError: Identifier 'letName' has already been declared ，用 name 命名的變數已經存在了，如下圖 但是 let 是有作用域 ( scope ) 的，就是用 { } 這個大括號，以下示範 上面介紹 var 那段，用大括號包起了並用 var 宣告相同變數的話，值還是會被後面命名的變數給覆蓋掉，但是在 let 並用 { } 將其中一個相同名稱的變數包起來，就會獨立出來，也不會跳出Identifier 'letName' has already been declared 這樣的 error 訊息， 在 console.log 輸入 window.letName 會顯示 undefined，由此可知全域變數也沒有受到汙染。 以下示範 let 的作用域差別只在全域變數不會受到汙染，以下示範。 1. 只在立即函式裡面宣告 let效果會跟 var 一樣，因為 var 在 function 裡面是受控制的不會到到處汙染，let 是因為 scope { } 的關係，所以也被限制住，scope 外面一樣讀取不到，所以會顯示 undefined。 123456;(function () { let letFunctionName = 'kevin' console.log('我是 function 裡面的 ' + letFunctionName)})()console.log('外面的' + letFunctionName) 用 window.letFunctionName 查看，全域一樣沒被汙染。 2. 在立即函式裡、外同時宣告 let效果跟 var 一樣。 1234567;(function () { let letFunctionName = 'kevin' console.log('我是 function 裡面的 ' + letFunctionName)})()let letFunctionName = 'ken'console.log('外面的' + letFunctionName) 但是輸入 window.letFunctionName 會顯示 undefined，全域一樣沒被汙染。 也就是說只要有 let 宣告加上 { } 的話，就會可以完全控制變數，不需要擔心變數相同名稱，也甭擔心全域變數會受到汙染。 DEMO const 的宣告 const = constant 的縮寫 const 一旦被賦值後就不能再更改了。錯誤示範 : 123const constArry = 10constArry = 999console.log(constArry) 但是有個特例雖然不能更改已經用 const 賦予的值，但是!! 可以更改物件或是陣列內的值。 範例一更陣列內指定的值 123const constArry = [10, 20, 30]constArry[0] = 999console.log(constArry) 是可以的。 範例二陣列內整個值換掉 123const constArry = [10, 20, 30]constArry = [666 777, 888]console.log(constArry) 是不行的，因為更改的已經是整個變數了，不是變數內的值。 DEMO 參考資料ES6 基础教学JavaScript 核心篇","link":"/2021/01/20/cosnt%E3%80%81var%E3%80%81let/"},{"title":"JavaScript 實作 - 明年倒數計時","text":"功能描述: 網頁載入會顯示 loading 效果。 loading 完會顯示距離明年倒數時間。 GithubDemo 架構用容器把顯示內容放在裡面，方便 loading 效果結束時控制這個容器要不要顯示。容器放置內容 跨年標題。 顯示倒數時間的天、時、分、秒。 Loading 效果。 1234567891011121314151617181920212223&lt;div class=\"container\"&gt; &lt;h1&gt;Happy New Year&lt;/h1&gt; &lt;ul id=\"countdown\" class=\"countdown\"&gt; &lt;li class=\"times\"&gt; &lt;p id=\"days\"&gt;00&lt;/p&gt; &lt;small&gt;days&lt;/small&gt; &lt;/li&gt; &lt;li class=\"times\"&gt; &lt;p id=\"hours\"&gt;00&lt;/p&gt; &lt;small&gt;hours&lt;/small&gt; &lt;/li&gt; &lt;li class=\"times\"&gt; &lt;p id=\"minutes\"&gt;00&lt;/p&gt; &lt;small&gt;minutes&lt;/small&gt; &lt;/li&gt; &lt;li class=\"times\"&gt; &lt;p id=\"seconds\"&gt;00&lt;/p&gt; &lt;small&gt;seconds&lt;/small&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;img src=\"./image/spinner.gif\" id=\"loading\" /&gt; 架構完成圖 CSS 樣式偽元素 ( before &amp; after )因為背景圖片太亮的關係導致文字顏色不是很明顯，可以透過偽元素將背景圖片的顏色刷黑一點，再用 z-index 屬性把文字呈現在最上層，這樣不只看到背景圖片又可以清楚看到文字。 偽元素必須要有 content 屬性，如果沒有效果會呈現不出來。 123456789body::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5);} z-index: 數字 : 數字越大代表越優先被排在畫面最上層。 我把文字內容放在 container 容器裡面，只要加入 z-index 屬性，就可以把文字內容放在暗色調的上一層。 123.container { z-index: 1;} 沒用偽元素 有用偽元素，字體顏色會比較清楚 JavaScript1. 計算公式查看目前還剩多少時間到明年元旦，可以用以下公式 12// 剩下時間 = 現在的年份 + 1 ( 明年元旦 ) - 現在的時間 ( 現在 )const totalTime = newYear - newTime 2. 現在時間用 new Date 抓取現在時間，有了現在時間的值再把值賦予到變數裡面，但要注意目前抓到的值是物件型別。 有了完整時間後，可以用 getFullYear 抓取現在年份同時轉換型別。 getFullYear : 用來取得一個 Date 物件的年份，時區是本地時間。 沒有 getFullYear 抓到的值會試完整時間，型別是物件型式。 123const times1 = new Date()console.log(times1)console.log(typeof times1) 有 getFullYear 就抓取當前的年份，同時轉成數字型別，轉型別的目的是為了方便把目前時間 +1 變成明年。 123const nowYear = new Date().getFullYear()console.log(nowYear)console.log(typeof nowYear) 3. 明年元旦時間把剛才用 getFullYear 轉換的年份 +1 就是明年年份。 12// 現在的年份 + 1 ( 明年 )const newYear = new Date(`January 01 ${nowYear + 1} 00:00:00`) 4. 倒數計時用 console 查看 totalTime 為總毫秒。( 毫秒 / 1000 ) = 秒( 毫秒 / 1000 ) % 60 = 當下的秒數。( 毫秒 / 1000 / 60 ) % 60 = 當下的分鐘數。( 毫秒 / 1000 / 60 /60 ) % 24 = 當下的小時數。( 毫秒 / 1000 / 60 /60 / 24) = 當下的天數。把算出來的值綁定到 dom 上，讓呈現在畫面上。 在不管是小時、分鐘、秒數都會有個位數，出現個位數前面可加 \"0\"，用三源判斷式。 12345678910111213141516171819202122function getTime() { const newTime = new Date() // console.log(newTime) const totalTime = newYear - newTime // console.log(totalTime) const day = Math.floor(totalTime / 1000 / 60 / 60 / 24) // console.log(day) const hours = Math.floor(totalTime / 1000 / 60 / 60) % 24 // console.log(hours) const minutes = Math.floor(totalTime / 1000 / 60) % 60 // console.log(minutes) const seconds = Math.floor(totalTime / 1000) % 60 // console.log(seconds) dayEl.innerHTML = day hourEl.innerHTML = hours &lt; 10 ? '0' + hours : hours minutesEL.innerHTML = minutes &lt; 10 ? '0' + minutes : minutes secondsEl.innerHTML = seconds &lt; 10 ? '0' + seconds : seconds}// getTime() 每秒執行一次setInterval(getTime, 1000) 5. loading 效果每刷新頁面就會顯示一下 loading 效果。 畫面載入一秒後移除 loading 效果，同時顯示時間。 1234setTimeout(() =&gt; { loading.remove() countdown.style.display = 'flex'}, 1000) 參考資料JavaScript Date getFullYear()CSS 偽元素 ( before 與 after )重新認識 JavaScript: Day 06 運算式與運算子","link":"/2021/02/05/countdown/"},{"title":"JavaScript 實作 - 拖曳效果","text":"功能描述: 刷新頁面打亂排列順序。 可以拖曳方塊排列順序。 確認排列順序是否正確。 GithubDemo 架構1234567&lt;h1&gt;苗栗國必去前10名景點&lt;/h1&gt;&lt;p&gt;請利用拖曳排列出這10名的順序&lt;/p&gt;&lt;ul class=\"draggable-list\" id=\"draggable-list\"&gt;&lt;/ul&gt;&lt;button class=\"check-btn\" id=\"check-btn\"&gt; Check Attractions &lt;i class=\"fas fa-paper-plane\"&gt;&lt;/i&gt;&lt;/button&gt; 拖曳方塊不能寫死，因為每次刷新頁面順序會打亂，打亂的順序排名用 javascript 撰寫。 CSS 樣式拖曳的時候會呈現色差 123.draggable-list li.over .draggable { background-color: #eaeaea;} 用顏色確認目前排列順序是否正確。 1234567.draggable-list li.right .person-name { color: #3ae374;}.draggable-list li.wrong .person-name { color: #ff3838;} 按鈕縮放效果 123.check-btn:active { transform: scale(0.98);} 點擊按鈕不要有邊框線條 123.check-btn:focus { outline: none;} JavaScript1. 綁定 DOM ，給初始值123456789101112131415161718const draggableList = document.querySelector('#draggable-list')const checkBtn = document.querySelector('#check-btn')const attractions = [ '客家大院', '後龍鎮半天寮休閒文化園區 - 好望角', '天空之城', '九華山 天空步道', '苗栗客家圓樓', '雅聞七里香玫瑰森林', '龍騰斷橋(魚藤坪斷橋)', '飛牛牧場', '銅鑼炮仗花海公園', '舊銅鑼隧道',]let dragStartIndexconst listItems = [] 2. 產生 DOM 並呈現在畫面上 展開運算符 ( Spread Operator ) :是把一個陣列展開成個別值，這個運算符後面必定接著一個陣列。最常見的是用來組合 ( 連接 ) 陣列。 其餘運算符 ( Rest Operator ) :是收集其餘的 ( 剩餘的 ) 這些值，轉變成一個陣列。它會用在函式定義時的傳入參數識別名定義 ( 其餘參數, Rest parameters )，以及解構賦值時 以上兩點引述自 : 展開運算符與其餘運算符 setAttribute( 'data-名稱', 'value 值') : 設定元件屬性，就是在元件上賦予名字跟值。不過這命名不能亂命，為了方面辨識或是避免搞混，在名稱前面會加上 data- 。以下範例用 console 查看 不過上面值是 number ，如果是字串要用 string，以下示範 123// 加兩個屬性listItem.setAttribute('data-id', 'dataId')listItem.setAttribute('data-name', 'dataName') 利用展開運算符把陣列內的景點變成個別的值，再用 forEach 產生每筆資料，每筆資料用 setAttribute 設定索引值，再把資料加入倒 ul 元件底下。 1234567891011121314151617181920creatListItem()function creatListItem() { ;[...attractions].forEach((person, index) =&gt; { const listItem = document.createElement('li') listItem.setAttribute('data-Index', index) //這不是設定className，單純的 name 跟 value listItem.innerHTML = ` &lt;span class='number'&gt;${index + 1}&lt;/span&gt; &lt;div class='draggable' draggable='true'&gt; &lt;p class='person-name'&gt;${person}&lt;/p&gt; &lt;i class='fas fa-grip-lines'&gt;&lt;/i&gt; &lt;/div&gt; ` listItems.push(listItem) draggableList.appendChild(listItem) }) addEventListeners()} 3. 資料隨機排列有了資料後，每次刷新頁面資料要隨機排列。要隨機排列就要有亂數，並且把亂數跟字串綁定，這樣每次刷新頁面順序就會是亂的。 把陣列內的字串用 map 產生出新的陣列 :將字串賦予到 value 裡面，再用 Math.random() 產生亂數，把這些亂數賦予到 sort 裡面，但是目前排列順序還是不對，必須依照我設定的順序跟數字綁定 1;[...attractions].map((a) =&gt; ({ value: a, sort: Math.random() })) sort() : 把資料依照正確順序排列。Codepen 12345678910// 本來陣列內數字是亂的，經過 sort 會依照大小排列const numbers = [1, 3, 9, 6, 20, 15]console.log( numbers.sort(function (a, b) { return a - b }))// arrow functionconsole.log(numbers.sort((a, b) =&gt; a - b)) 看過上面的解釋後，接下來要把陣列內的字串跟正確的數字順序做綁定。 1;[...attractions].sort((a, b) =&gt; a.sort - b.sort) 比照上面那張圖，原本是亂掉的，現在依照陣列內的順序讓數字由小到大排列。 有了順序後，數字不被看見，只要取 value 就好。 1.map((a) =&gt; a.value) 4. 拖曳效果下表參考自 : HTML5 Drag and Drop API 筆記| | Drag Source | Drag Target |解釋 || ——– | ——– | ——– |——– || 1 | dragstart| |開始拖曳元素時觸發此事件|| 2 | drag | dragenter |拖曳元素時觸發此事件|| 3 | | dragover |當元素拖曳到有效位置放置則觸發此事件|| 4 | | dragleave |拖曳的元素離開有效的位置時觸發|| 5 | | drop |在有效位置上放置元素時觸發此事件|| 6 | dropend | |當拖曳結束時會觸發此事件| 這段來自 : 製作可拖曳的元素（HTML5 Drag and Drop API） &gt; Drag Source 指的是被點擊要拖曳的物件，也就是藍色的圓，通常是一個 element。 Drop Target 指的是拖曳的物件被放置的區域，也就是右邊的綠色區域，通常是一個 div container。 drag：在 drag source 被拖曳時會持續被觸發。 dragover：當拖曳的 drag source 在 drop target 上方時會持續被觸發。 12345678910111213141516function addEventListeners() { const draggables = document.querySelectorAll('.draggable') const dragListItems = document.querySelectorAll('.draggable-list li') //選到 ul 底下所有 li ( 因為 li 沒有 calssName ，所以這樣寫) draggables.forEach((draggable) =&gt; { draggable.addEventListener('dragstart', dragStart) }) dragListItems.forEach((item) =&gt; { item.addEventListener('dragover', dragOver) item.addEventListener('drop', dragDrag) item.addEventListener('dragenter', dragEnter) item.addEventListener('dragleave', dragLeave) })} 拖曳時更換顏色 123456789function dragEnter() { // console.log('Event: ', 'dragEnter') this.classList.add('over')}function dragLeave() { // console.log('Event: ', 'dragLeave') this.classList.remove('over')} 當我拖曳時 dragstart 就會開始抓取當前的索引值 12345678function dragStart() { // console.log('Event: ', 'dragStart') //拖曳的時候抓取索引值 dragStartIndex = +this.closest('li').getAttribute('data-Index') //上面設定索引值，這裡抓索引值，+ 號改型別用 // console.log(dragStartIndex) // console.log(typeof dragStartIndex)} 如果沒有 + 號，當我拖曳第一個，用 console 看會顯示下圖 有 + 號 抓到索引值後把拖曳到該欄位的索引值對換。 1234567891011121314function dragDrag() { // console.log('Event: ', 'dragDrag') const dragEndIndex = +this.getAttribute('data-Index') swapItems(dragStartIndex, dragEndIndex) this.classList.remove('over')}function swapItems(from, to) { const itemOne = listItems[from].querySelector('.draggable') const itemTwo = listItems[to].querySelector('.draggable') listItems[from].appendChild(itemTwo) listItems[to].appendChild(itemOne)} 5. 確認清單順序是否正確1234567891011121314function checkOrder() { listItems.forEach((listItem, index) =&gt; { const personName = listItem.querySelector('.draggable').innerText.trim() if (personName !== attractions[index]) { listItem.classList.add('wrong') } else { listItem.classList.remove('wrong') listItem.classList.add('right') } })}checkBtn.addEventListener('click', checkOrder) 參考資料展開運算符與其餘運算符HTML5 Drag and Drop API 筆記製作可拖曳的元素（HTML5 Drag and Drop API）20 Web Projects With Vanilla JavaScript","link":"/2021/02/08/dragdrop/"},{"title":"JavaScript 實作 - 簡易表單驗證","text":"功能敘述：確認使用者輸入的資料是否正確。 GithubDemo 第一部分: 刻板+上色先寫好要一般 form 表單要填寫的資料， 使用者名稱 使用者信箱 密碼 密碼 2 次驗證 上色跟輸入框的間隔可依照個人喜好設定 1234567891011121314151617181920212223242526272829303132&lt;div class=\"container\"&gt;&lt;!-- 輸入使用者名稱 --&gt;&lt;form class='form' id='form'&gt; &lt;h1&gt;表單驗證&lt;/h1&gt; &lt;div class=\"formControl\"&gt; &lt;label for=\"username\"&gt;UserName:&lt;/label&gt; &lt;input type=\"text\" id=\"username\" placeholder=\"Key in UserName\"&gt; &lt;small class='failMessage'&gt;Error message&lt;/small&gt; &lt;/div&gt; &lt;!-- 輸入使用者e-mail --&gt; &lt;div class=\"formControl\"&gt; &lt;label for=\"email\"&gt;E-mail:&lt;/label&gt; &lt;input type=\"text\" id=\"email\" placeholder=\"Key in E-mail\"&gt; &lt;small class='failMessage'&gt;Error message&lt;/small&gt; &lt;/div&gt; &lt;!-- 輸入使用者密碼 --&gt; &lt;div class=\"formControl\"&gt; &lt;label for=\"password\"&gt;Password:&lt;/label&gt; &lt;input type=\"password\" id=\"password\" placeholder=\"Key in password\"&gt; &lt;small class='failMessage'&gt;密碼錯誤&lt;/small&gt; &lt;/div&gt; &lt;!-- 確認使用者密碼 --&gt; &lt;div class=\"formControl\"&gt; &lt;label for=\"confirmPassword\"&gt;Confirm Password:&lt;/label&gt; &lt;input type=\"password\" id=\"confirmPassword\" placeholder=\"Key in password again\"&gt; &lt;small class='failMessage'&gt;請重新輸入密碼&lt;/small&gt; &lt;/div&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;/div&gt;&lt;script src=\"./all.js\"&gt;&lt;/script&gt;&lt;/body&gt; 第二部分: 驗證1. 抓取 DOM先抓取 dom 元素，因為是抓 id 所以是用 # 123456// 抓取 dom 元素const form = document.querySelector('#form')const username = document.querySelector('#username')const email = document.querySelector('#email')const password = document.querySelector('#password')const confirmPassword = document.querySelector('#confirmPassword') 2. 常用的獨立寫出來因為只要寫錯就會顯示錯誤訊息，這動作很重複所以將這些函式獨立拉出來，利用 callback function 的方式重複使用要特別注意以下兩點 是第 3 行 formControl 必須要用 父元素 的方式不能用 class 選擇器，不然它只會抓取 class 選擇器的最後一個，不會抓到每個 input 輸入框的父層 第 5 行的 small 必須用 formControl 的方式抓，不能用 document ，不然會抓不到 123456789101112131415161718// 失敗顯示function showFail(input, message) { const formControl = input.parentElement formControl.className = 'formControl fail' const small = formControl.querySelector('small') small.innerText = message}// 成功顯示function showSuccess(input) { const formControl = input.parentElement formControl.className = 'formControl success'}// 第一字體變大寫function getFiledName(input) { return input.id.slice(0, 1).toUpperCase() + input.id.slice(1).toLowerCase()} 3. 取消重複性因為每個 dom 的 input 都要驗證的話就會有很多 if else 判斷式，這時候可以用 javascript 的 forEach 來讀取每個 dom ，然後再寫一次 if else 就可以每個都判斷 checkInput 裡面的值用陣列顯示，那每個質都要被讀取到就用 forEach ，在陣列中的 dom 因為綁了 input 所以直接帶入是否是空值得判斷式，因為如果寫在裡面會太大包，造成日後不好維護，外加太醜，所以這邊直接用 callback function 的方式 12345678910111213// 輸入框輸入確認function checkInput(inputId) { inputId.forEach(inputArr)}// 輸入框 callback functionfunction inputArr(input) { if (input.value.trim() === '') { showFail(input, `${getFiledName(input)} is require`) } else { showSuccess(input) }} 4. 驗證( 1 ) 使用者名稱長度的驗證為了防止使用者名字長度過長或是過短，所以要設定一個卡關機制 12345678910111213// 輸入使用者名稱跟密碼長度限制function checkLength(input, min, max) { if (input.value.length &lt; min) { showFail(input, `${getFiledName(input)} must be at least ${min} characters`) } else if (input.value.length &gt; max) { showFail( input, `${getFiledName(input)} must be less than ${max} characters` ) } else { showSuccess(input) }} ( 2 ) 信箱驗證12345678910// 信箱正規表達驗證function checkMail(input) { const re = /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/ // return re.test(String(email).toLowerCase()) if (re.test(input.value)) { showSuccess(input) } else { showFail(input, 'email is not valid') }} ( 3 ) 密碼雙重驗證123456// 密碼雙重驗證function checkPasswordMatch(password, confirmPassword) { if (password.value !== confirmPassword.value) { showFail(confirmPassword, 'password is not match') }} ( 4 ) 執行123456789// 執行form.addEventListener('submit', function (e) { e.preventDefault() checkInput([username, email, password, confirmPassword]) checkLength(username, 3, 8) checkLength(password, 3, 12) checkMail(email) checkPasswordMatch(password, confirmPassword)}) Demo參考資料20 Web Projects With Vanilla JavaScript","link":"/2020/12/31/formVaild/"},{"title":"Git - 基本操作","text":"簡介Git 是一個可控制程式碼版本的工具當我們在開發的時候為了不影響線上的產品，就會先開一個分支出來在分支上做開發，這樣既可以大膽的開發也不怕會影響到線上正在運行的版本，同時又做到程式碼的控管，是一個很方便的工具 Git 指令Git 有分幾個簡單寫常用的幾個指令git init: 在我們 local 端建立數據庫git add .: 加入索引git commit -m: 將目前加入索引的資料提交出去git push origin: 推送到遠端數據庫git pull: 從遠端數據庫拉取最新的版本git branch: 查看分支git checkout : 切換到該分支git log: 查看 git 歷史紀錄git status: 查看目前資料狀態git merge: 合併分支 工作上常用的大概是以上這幾種 安裝OS: window首先到 Git 官網下載 Git 或是用 chcoclatey 安裝也可以 ，輸入choco install git 初次安裝的話會需要設定使用者名稱跟密碼 初始化安裝完成後在桌面建立資料夾，並簡單新增檔案，然後再對資料夾案右鍵，選取 Git Bash Here會出現 Bash 視窗這樣就初始化完成了 加入索引接下來就可以開發了 本來是檔案內容是空的，現在加入一點基本資料，然後要將這資料加入索引當我們新增或是更改完成時就要將資料新增到索引，同時放到一個暫存區裡面因為 VScode 有內建 git add ，就是下圖紅框處，如果有更改某檔案的資料，在 changes 就會有紀錄，首先左邊選單選到 Source control 會看到有檔案變更，點擊紅框的 + 號，要加入索引就把滑鼠移至紅框，會出現 + 號，點擊就 add 了 add 新增索引後，如下圖 提交當確定好更改的檔案並加入索引後，我們要 commit ，把暫存區裡面的資料丟到儲存庫裡面通常 commit 後面都會接此次更改的資訊，寫法如下git commit -m \"add index.html\"，要記得空格跟加雙引號 然後推送至遠端數據庫 建立遠端儲存庫在推送至遠端數據庫之前，要先在遠端建立遠端數據庫，那這會用到 Github ，如果沒有 Github 要先辦一下登入後看到右上角有個 + 號，點擊候選取 New repository會出現以下畫面，然後再紅框處輸入遠端數據庫的名稱，這邊用 test1 示範，然後點擊下面的Create repository 接著會顯示以下畫面 推送至遠端數據庫當我們把資料都丟到數據庫後，接下來要將新增或是修改的檔案推送到遠端數據庫中git push origin test ，意思是將 test 這個分之 push 到遠端的數據庫中因為我剛剛已經 init、add、commit 了，所以現在就直接 push，點選右邊紅框的複製紐直接貼上 用 git log 指令確認一下狀態 在回到 Github 在刷新一次頁面，確認一下 這樣不管是 loacal 或是 remote，前置作業就算是完成了 製造分支接下來我們可以試著用分支開發造分支有兩種方法: git checkout -b 分支名稱: 這方法比較直接，輸入完直接造分支同時切到該分支上 git branch 分支名稱: 這方法會造分支但不會切換到該分支，必須再下 git checkout 分支名稱 才會切過去，以下示範我先用 branch 創造分支 dev2 ，然後再確認目前在哪個分支上(亮綠色有星號的就是在該分支上)但因為我創的是 dev2 ，所以還沒轉過去，要用 checkout 才可以切換過去 合併分支接下來流程跟上面步驟一樣 建立索引 add 或是 按 + 提交至儲存庫 git commit 推送至遠端 實際操作: 確認在哪個分之 在分支上新增 h2 內容，並加入索引 用 git status 確認目前更改的檔案有哪些 如下圖 提交到儲存庫後，左邊的暫存檔就會不見 再示範一次，新增 h3 內容我們可以點擊更改的檔案查看哪邊有高亮，有代表變更的地方 提交後。高亮就會不見 再推送到遠端git push origin 分支名稱 到遠端切換到分支上查看，確實有剛新增的內容 接下來要合併了切回 主支( main ) 可以看到沒有 h2、h3 的內容但再切回 dev1 分支查看是有的 合併時我們要先切到要被合併的那個分支上，可以用 git branch 確認高亮跟星號在哪，如下圖merge 完後 dev1 的內容就會被新增到主支(main)上，然後就可以繼續做開發了 參考資料把檔案交給 Git 控管","link":"/2020/12/20/git/"},{"title":"Vue - MVVM 簡介","text":"介紹MVVM 是由 Model、View 跟 ViewModel 這三個東西之間的作用，可以比較好管理開發者的內容。 Model：管理資料來源如 API 和本地資料庫 View：顯示 UI 和接收使用者動作 ViewModel：從 Model 取得 View 所需的資料 使用者透過 view 操作來影響 view model ，只要在 view 裡面操做， view model 同時也會跟著變動，同時也修改 model 的內容，那 view model 資料發生變動，又會同時改變 View 顯示的內容，所以他們三個是互相交互作用的。 Vue 強大的地方在於 Vue 組件，他可以把龐大的 App 分裝，把相關的功能集中，讓這些組件獨立封裝而且好維護也好測試。 參考資料精通 VueJS 前端開發完全指南MVVM 架構","link":"/2021/02/22/mvvm/"},{"title":"Vue - 父組件傳遞到子組件的  props 語法","text":"簡介當組件化的網頁要從後端伺服器請求資料的時候，那些回傳的資料都會經過父層組件傳到子層組件去，那父層組件的參數要傳到子層組件的話就要透過 props 語法。 1. props 沒有限制型別沒有限制型別的寫法就是說待會在接收父層的資料的時候不會有限制。 套用之前的範例，這是在不需要從 Vue 實例 ( 父層 ) 傳參數的寫法。 123456789&lt;div id=\"app\"&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h1&gt;{{message}}&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415const cpn = { template: '#cpn', data() { return { message: 'Hello World', } },}const app = new Vue({ el: '#app', components: { cpn, },}) 正常會顯示下圖 但是現在要從 Vue 實例 ( 父層 ) 傳變數，那我們先在父層新增一些資料，同時又要接收資料。 方法如下: 在組件內先新增 props 屬性，然後在陣列內新增變數，變數的名稱是自定義的 ( JS 第 4 行 ) 。 在模板中新新增組件標籤 ( HTML 第 8、9 行 )。 在組件標籤上動態綁定父子組件 ( HTML 第 2 行 ) 。 props 陣列內寫的是變數，不是字串。 1234567891011121314&lt;div id=\"app\"&gt; &lt;cpn :cmovies=\"movies\" :cmessage=\"message\"&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h2&gt;{{cmovies}}&lt;/h2&gt; &lt;h2&gt;{{cmessage}}&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=\"item in cmovies\"&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516const cpn = { template: '#cpn', // 1. 沒有限制型別的寫法 props: ['cmovies', 'cmessage'],}const app = new Vue({ el: '#app', data: { message: 'Hello world', movies: ['索爾', '鋼鐵人', '綠巨人浩克'], }, components: { cpn, },}) 這樣就子組件就可以從父層拿到資料並渲染 DEMO 2. props 驗證資料上面範例是子組件在接收父層組件資料的時候沒有限制型別的寫法，而且 props 接收的明明是變數，但看起來卻像是字串，接下來要寫的是 props 接收到的資料需要驗證的寫法。 方法很簡單，HTML 模板內容不變，將 props 改成陣列再把子組件名稱改成 key 值跟對應的 value 值。 12345678910111213141516171819202122const cpn = { template: '#cpn', // 1. 沒有限制型別的寫法 // props:['cmovies', 'cmessage'], // 2. 限制型別的寫法 props: { cmovies: Array, cmessage: String, },}const app = new Vue({ el: '#app', data: { message: 'Hello world', movies: ['索爾', '鋼鐵人', '綠巨人浩克'], }, components: { cpn, },}) 一樣可以顯示 DEMO 3. 設定默認值的寫法當我在模板標籤中沒有動態綁定父子組件的話，會自動顯示子組件預設的默認值。以下會示範當沒有動綁定的話會怎麼顯示。 要設定默認值有兩種寫法: default 直接給值 ( JS 第 15 行 )。 default 已函式的型式給值 ( JS 第 17 行)。 現在故意在模板上少寫動態綁定的其中一項 ( HTML 第 5、6 行)。 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;cpn :cmovies=\"movies\" :cmessage=\"message\"&gt;&lt;/cpn&gt; &lt;!-- 沒有從父組件拿到 message 參數，顯示默認值 --&gt; &lt;cpn :cmessage=\"message\"&gt;&lt;/cpn&gt; &lt;cpn :cmovies=\"movies\"&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h2&gt;{{cmessage}}&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=\"item in cmovies\"&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const cpn = { template: '#cpn', // 1. 沒有限制型別的寫法 // props:['cmovies', 'cmessage'], // 2. 限制型別的寫法 // props:{ // cmovies: Array, // cmessage: String // }, // 3. 設定預設值寫法 props: { cmessage: { type: String, // default: 'none', //這是第一種寫法 default() { return { message: '這是第2種寫法，以函式表示的 message', } }, require: true, //必須要有的，如果有少就會報錯 }, cmovies: { type: String, default() { //這是第2種寫法，以函式表示 return ['超人', '閃電俠', '神力女超人'] }, require: true, //必須要有的，如果有少就會報錯 }, }, data() { return {} },}const app = new Vue({ el: '#app', data: { message: 'Hello world', movies: ['索爾', '鋼鐵人', '綠巨人浩克'], }, components: { cpn, },}) 顯示下圖。 DEMO 比較需要注意的是標籤上的命名，在組件中是可以接受小駝峰的，但是在 #app 裡面的標籤只能接受全小寫或是串接式寫法 ( kebab Case ) ，盡量以串接式寫法為主。 參考資料2019 年最全最新 Vue、Vuejs 教程，从入门到精通","link":"/2021/03/02/props/"},{"title":"Git - 如何發 PR 完成協作 ( Pull Request )","text":"git clone、git pull 這兩個指令有什麼不同，又分別代表什麼意思。 Pull Request 的流程是甚麼 為什麼需要透過 Pull Request 來開發 git clone、git pull 這兩個指令有什麼不同，又分別代表什麼意思。兩個都是更新檔案，repository 更新的過程會不一樣，一個是整包下載，一個是下載本地端已經有只需要下載部分更新的檔案，兩個同樣都是把檔案更新到最新的狀態 git clone :在本地( local )端還沒有 repository 的狀況下，我們就會需要使用到 clone ，把整包 repository 載下來，一般也只需要 clone 一次，之後就只需要 pull 了。 git pull :就是我們本地( local )端已經有 repository 了，這時候就不需要在 clone ，只需要透過 pull 的方式，將遠端 ( remote )的 repository 載下來就可以了 以上就是 clone、pull 的差別 為什麼需要透過 Pull Request 來開發一般在開發或是看到很有興趣的開源專案，如果想加入新功能或是加入開發專安的話就會需要使用到 Pull Request，也就是我們俗稱的 PR Pull Request 的流程是甚麼Pull Request 簡稱 PR如果已經是這個團隊的開者之一，那就單純 clone 就好，如果是別的開源專案又不是這個專案的原始開發者之一，那就需要先將專案 fork 出來，再開始開發 以饅頭計畫的專案為例，我們已經是這個專案的開發人員之一，所以只需要 clone 下來就好，然後開分之並在分支上進行開發，做完之後我們會需要 push 到 remote repository，這時候就要發 PR 了，讓資深工程師確認我們寫的需求有沒有問題，如果沒問題就會 merge 到主支上 以下示範:因為之前已經 clone 過了，請記得先切換到主之上，然後再把本地端的檔案 pull 到最新的狀態，然後再用 git checkout -b 分支名稱，創建該分支同時切換到該分支上，如下圖 接下來就是 Git 基本操作了在分支上新增好內容後，把新增或是更改資料加入索引 然後提交(commit)上去出現git push --set-upstream origin example-mission的原因可以參考這篇文章解決方法就是複製貼上… 上面太模糊..補上清晰版… push 上去後到 Github 專案點選左上 Pull Request，因為目前還沒有發 PR，所以沒看到我剛新增的內容。要發 PR 的話要點選右邊那兩個紅框的， 一種是 Compare &amp; pull request ，另一種是New pull request，兩個都可以發，過程不一樣而已，以下兩種都會示範 New pull request點擊 New pull request 會顯示下圖畫面，左邊 base:main 是主支千萬不要動到，動右邊要 merge 的分支就好因為我們要把剛才新增的內容合併到主之上，所以選擇剛才新增的分支名稱 example-mission 選完就會顯示剛才新增的內容，如下圖，確認 OK 後點選右邊的 Create pull request 接著會進入以下畫面，這邊就要寫一下大標題，還有較細項的更改內容，填寫完後再按右下的 Create pull request 按下後會進入以下畫面 再回到 Pull Request 刷新一下，就會看到剛才新發的 PR 了 接下來就等資深工程師確認我們寫的內容有無問題，沒問題就會按下 Merge pull request，合併到主支(main)上 Compare &amp; pull request這邊更簡單，也推薦使用這個因為點選 Compare &amp; pull request 後系統會自動選取剛才新建的分支上，會顯示下圖 接著叫輸入大標題跟內容再 Create pull request ，這樣 PR 就發完了 參考資料與其它開發者的互動 - 使用 Pull Request（PR） - 為你自己學 Git | 高見龍git add、git commit - 提交版本Git master branch has no upstream branch 的解決","link":"/2020/12/28/pullRequest/"},{"title":"Vue - Router","text":"新增路由路徑及連結 Vue-router:官方文件 透過切換網址來決定要顯示的組件內容，而切換網址就要用 router 來幫你達成! 在終端機切換到自己命名的資料夾並安裝 npm install vue-router --save 到 index.js 引入 Vue.use() ，啟用路由功能 12345678910111213141516171819202122232425262728293031import Vue from 'vue'import VueRouter from 'vue-router'//以上為官方元件// 這邊路徑就是左邊檔案路徑，保險起見一律都不加 .vue 字尾!!!// 路徑除了 from 要加入根目錄的 '@' 以外，其他地方不要加import home from '@/components/HelloWorld'import page from '@/components/pages/page'Vue.use(VueRouter) //路由啟用。這行很重要!!export default new VueRouter({ // 這邊路徑是自訂的 routes: [ { name: '元件呈現的名稱', path: '對應的虛擬路徑', component: 對應的元件, }, { path: '/index', name: 'home', component: home, }, { path: '/page', name: 'page', component: page, }, ],}) export 解釋路由載入完啟用後，再到 main.js 載入路由配置 123456789101112import Vue from 'vue'import App from './App'import router from './router' //新增這行Vue.config.productionTip = falsenew Vue({ el: '#app', components: { App }, template: '&lt;App/&gt;', router, //跟這行}) 這邊示範一下透過設定的路徑來顯示組件內容 因為首頁(HelloWorld.vue)的路徑(path)我定義為 /index ，所以在網址上如果沒有輸入定義路徑會顯示下圖可以看到，畫面只會顯示 app.vue 的圖片沒有其他內容，但如果在網址後面輸入 /index ，就會顯示下圖這樣就可以看到 HelloWorld.vue 的內容 接下來使用 BS4 套件，來快速顯示組件的內容首先，在 index.html 引入 BS4 cdn有分頁才會有不同路徑，所以在 components 底下新增 pages 資料夾，裡面新增 page.vue 到 page.vue 新增模板記得在模板內加上 div (這邊用 hello 標籤示範)。接著在標籤內貼上 BS4 套件(這邊用 card 套件示範)，src 裡面的 …記得刪除!!，不然會錯誤!! 123456789101112131415&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;div class=\"card\" style=\"width: 18rem;\"&gt; &lt;img src=\"\" class=\"card-img-top\" alt=\"...\" /&gt; &lt;div class=\"card-body\"&gt; &lt;h5 class=\"card-title\"&gt;Card title&lt;/h5&gt; &lt;p class=\"card-text\"&gt; Some quick example text to build on the card title and make up the bulk of the card's content. &lt;/p&gt; &lt;a href=\"#\" class=\"btn btn-primary\"&gt;Go somewhere&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 再來要製做可以切換組件內容的 navbar先把 app.vue 內容刪除，留下 app 標籤跟 router-view，img 也可以留下做分隔，並在裡面套入 BS4 導覽列套件，然後把不要的內容刪掉並補上 vue 的連結標籤，這邊的連結已經不是&lt; a href=”#” &gt; 了，而是 router-link ，連結路徑用 to ，這個路徑是 index.js 裡面自定義的路徑，記得要寫 router-view 這樣才可以顯示組件，如下圖 這邊說明一下 router-view：router-view 是呈現 router/index.js 裡面的元件，而 router/index.js 是設定各元件之間的連結 完成後會看到畫面如下沒有任何組件，因為網址還沒輸入任何自定義路徑 按一下 index，會顯示下圖 按一下 page，會顯示下圖 製作巢狀路由頁面接下來要做巢狀路由 注意!!!!在巢狀裡面一律不加斜號 ‘/‘ !!! 參考文件繼續在 pages 資料夾下新建立 3 個組件(這邊用 childX 示範)，然後再引入 BS4 套件的，只是要辨別而以所以用簡單的 alert 套件就好(其實是懶) 123456這是 child1 範本&lt;template&gt; &lt;div&gt; &lt;div class=\"alert alert-primary\" role=\"alert\"&gt;child1&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 因為我們要在 page 裡面切換 child 組件，所以先把 card 套件內的內容通通刪掉並補上 router-view 1234567&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;div class=\"card\" style=\"width: 18rem;\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 接下來要自定義路徑，但這是巢狀路徑，所以要在 page 底下加上 children，這 children 是使用陣列，裡面內容就跟外面的物件一樣，但在的第一個子元件的路徑可以是空直，這樣只要切到 page 頁面就會自動載入 child1 元件，子元件下陣列內的路徑也甭加 ‘/‘ ，直接寫路徑名字就好。下面組件新增完後上面也要引入組件路徑。範例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import Vue from 'vue'import Router from 'vue-router'//以上為官方元件// 這邊路徑就是左邊檔案路徑import home from '@/components/HelloWorld'import page from '@/components/pages/page'import child1 from '@/components/pages/child1'import child2 from '@/components/pages/child2'import child3 from '@/components/pages/child3'Vue.use(Router) // 路由啟用。這行很重要!!export default new Router({ // 這邊路徑是自訂的 routes: [ { path: '/index', //對應的虛擬路徑 name: 'home', //元件呈現的名稱 component: home, //對應的元件 }, { path: '/page', //對應的虛擬路徑 name: 'page', //元件呈現的名稱 component: page, //對應的元件 children: [ { path: '', //對應的虛擬路徑 name: 'child1', //元件呈現的名稱 component: child1, //對應的元件 }, { path: 'child2', //對應的虛擬路徑 name: 'child2', //元件呈現的名稱 component: child2, //對應的元件 }, { path: 'child3', //對應的虛擬路徑 name: 'child3', //元件呈現的名稱 component: child3, //對應的元件 }, ], }, ],}) OK，到目前為止我們只要切換網址就可以看到 child 組件了，先試試 page 頁我有在 app.vue 用 container 限制寬並置中 可以看到目前在 page 頁，並自動帶入 child1輸入 child2 如下圖 接下來要在 page 頁面下新增子分頁的連結， 1234567891011121314&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;router-link to=\"/page/\"&gt;child1&lt;/router-link&gt; &lt;router-link to=\"/page/child2\"&gt;child2&lt;/router-link&gt; &lt;router-link to=\"/page/child3\"&gt;child3&lt;/router-link&gt; &lt;!-- 也可以用 v-bind 動態綁定 name 的方式來連結路徑，下面示範 --&gt; &lt;router-link :to=\"{ name: 'child3' }\"&gt;child3&lt;/router-link&gt; &lt;div class=\"card\" style=\"width: 18rem;\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 結果如下圖，本想把 card 套件移除，但發現他剛好可以把 alert 套件框住不會滿版，就索性留著然後注意網址!!!在點擊子組件的時候就會切換到自訂義的網址，同時也顯示不同子頁面 參考資料：Vue 出電商網站Vue 官方文件搞搞就懂部落格","link":"/2020/08/30/router/"},{"title":"jQuery - 介紹","text":"三大重點 選擇器 (selector) 事件觸發 (event) 事件處發的回調函數 撰寫步驟如下: 選擇: 顯示、隱藏元素 事件: 改變樣式 動作: DOM 操作 選擇器 (Selector)id 選擇器利用按下 button 按鈕改變字體顏色 以下示範:首先給個 id 元素跟 button 12&lt;div id=\"color\"&gt;color&lt;/div&gt;&lt;button id='changeColor'&gt;Button&lt;/button&gt; 再來是執行步驟: 選擇要改變的元素 #color 改變顏色 css('color', 'red') 在 click 動作下執行 1234$('#changeColor').click(function(){ $('#color').css('color', 'red')}) DEMO class 選擇器來看一下跟 id 選擇器有什麼差別 給同個 id &amp; className 再用 console.log 查看 12&lt;div id=\"dog\" class=\"dog\"&gt;dog 1&lt;/div&gt;&lt;div id=\"dog\" class=\"dog\"&gt;dog 2&lt;/div&gt; 先示範選擇器抓 id 的效果然後在 console.log 下 $('#dog').text()，顯示如下只會抓到第一個 id 的 dog 而已 再試試選擇器抓 className 的話呢?輸入 $('.dog').text() ，顯示如下紅框處 綠色是選擇器的差別上面是 id ，下面是 className可以看如果用 className 選擇器的話兩個都會顯示 DEMO 元素選擇器觀念跟 class 很像，可以同時更改多個元素內容或樣式，但會有點風險，因為同個檔案裡面或有多個相同元素 給三個 p 元素跟一個 button ，透過按下 button 可以更改元素內的內容，以下示範 12345&lt;p&gt;p1&lt;/p&gt;&lt;p&gt;p2&lt;/p&gt;&lt;p&gt;p3&lt;/p&gt;&lt;button id=\"changeWord\"&gt;change-Word&lt;/button&gt; jQuery 步驟: 選擇要改變的元素 p 改變的樣式 .text('changeWord') 按下 button 的動作 1234$('#changeWord').click(function(){ $('p').text('changeWord')}) DEMO 總結 id 、 className &amp; 元素的差別: id: 若有很多相同 id ，只會選取第一個 className: 會同時選取所有相同的 className 元素: 會同時選取所有相同的元素 會用到 className 的原因是為了方便選更改多個樣式，可以用在相同的商品列表上，但如果選擇 id 的話就只會更改單一樣式而且是第一個，之後相同 id 的不會更改到 參考資料:jQuery 幼幼班","link":"/2021/01/14/selector/"},{"title":"JavaScript 實作 - 打字遊戲","text":"功能敘述： 在時間內輸入顯示的單字可以得分。 依照難度調整獎勵時間。 時間內未輸入完成會顯示新訊息。 GithubDemo 功能需求 進入頁面後隨機產生文字。 可以直接在輸入框輸入單字(不需要滑鼠點擊輸入框)，輸入正確得一分。 進入頁面後時間開始倒數，若輸入正確倒數時間會增加。 時間內沒寫完會顯示時間到的訊息。 增加的時間可以依照難度調整獎勵時間。 難度選單可以選擇隱藏或是顯示。 刷新頁面後難度不會被回復預設值。 模板架構 button 顯是隱藏難度。 難度選單。 顯示隨機產生的文字。 輸入框。 顯示時間跟分數。 1. 顯示隱藏難度123&lt;button id=\"settings-btn\" class=\"settings-btn\"&gt; &lt;i class=\"fas fa-cog\"&gt;&lt;/i&gt;&lt;/button&gt; 2. 難度選單123456789101112&lt;div id=\"settings\" class=\"settings\"&gt; &lt;form id=\"settings-form\"&gt; &lt;div&gt; &lt;label for=\"difficulty\"&gt;Difficulty&lt;/label&gt; &lt;select id=\"difficulty\"&gt; &lt;option value=\"easy\"&gt;Easy&lt;/option&gt; &lt;option value=\"medium\"&gt;Medium&lt;/option&gt; &lt;option value=\"hard\"&gt;Hard&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; 3. 顯示隨機產生的文字、輸入框、顯示時間跟分數12345678910111213141516171819&lt;div class=\"container\"&gt; &lt;h2&gt;👩‍💻 Speed Typer 👨‍💻&lt;/h2&gt; &lt;small&gt;Type the following:&lt;/small&gt; &lt;h1 id=\"word\"&gt;&lt;/h1&gt; &lt;input type=\"text\" id=\"text\" autocomplete=\"off\" placeholder=\"Type the word here...\" /&gt; &lt;p class=\"time-container\"&gt;Time left: &lt;span id=\"time\"&gt;10s&lt;/span&gt;&lt;/p&gt; &lt;p class=\"score-container\"&gt;Score: &lt;span id=\"score\"&gt;0&lt;/span&gt;&lt;/p&gt; &lt;div id=\"end-game-container\" class=\"end-game-container\"&gt;&lt;/div&gt;&lt;/div&gt; 架構完成圖 CSS 樣式可以依照個人喜好來設定。 功能撰寫 ( JavaScript )1. 將 DOM 跟元素做綁定123456789const word = document.getElementById('word')const text = document.getElementById('text')const scoreEl = document.getElementById('score')const timeEl = document.getElementById('time')const endgameEl = document.getElementById('end-game-container')const settingsBtn = document.getElementById('settings-btn')const settings = document.getElementById('settings')const settingsForm = document.getElementById('settings-form')const difficultySelect = document.getElementById('difficulty') 2. 進入頁面後隨機產生文字。文字資料可以透過 API 獲取。或是像作者直接給陣列值再用 Math.random、Math.floor、words.length的方式隨機抓取一個值。 打 API 要資料的方法有三種 Ajax、axios、fetch，以下用 axios 示範，選用 axios 是因為比較簡單，直接給 API url ，再用 then 抓取回傳的資料就可以了，如果資料回傳錯誤就會走 catch 。用 console 查看 response 的資料如下圖 有了這值後再把值賦予到 randomWord 變數上，讓其他函示可以取用。 123456789101112131415// 用 Axios 打 API 抓取 response 的值function getRandomWord() { axios .get('https://random-word-api.herokuapp.com/word?number=1') .then((res) =&gt; { // console.log(res); randomWord = res.data[0] // console.log(randomWord); word.innerHTML = randomWord }) .catch((error) =&gt; { console.log('沒抓到單字資料') })}getRandomWord() 3. 比對輸入的值是否吻合再給予獎勵focus() : 打開視窗就可以直接輸入單字了。 把 e.target.value 抓到的值賦予到 inputText 變數上，方便跟上面拆分的 randomWord 做比對，要注意 randomWord 不能用 cosnt 、let、var 宣告，不然會抓不到，比對成功後，分數會加 1，同時給予獎勵增長時間 5 秒。 123456789101112131415161718192021text.focus()// 答對加分，同時把分數綁到 DOM 上function updateScore() { score++ scoreEl.innerHTML = score}// 在輸入框輸入文字同時跟顯示的文字做對比text.addEventListener('input', (e) =&gt; { let inputText = e.target.value if (inputText === randomWord) { getRandomWord() updateScore() e.target.value = '' //只能用 e.target.value 來清空值 time += 5 updateTime() }}) 4. 時間內沒寫完會顯示時間到的訊息。輸入文字的同時時間也會開始倒數，倒數的數字要設置停損點 ( clearInterval )，不然會數到負的。 setInterval : 是設定固定時間重複循環的語法。 12345678910111213141516171819const initTime = setInterval(updateTime, 1000)function updateTime() { // 時間開始倒扣 time-- // 倒扣的時間顯示在 DOM 上 timeEl.innerHTML = time + ' s ' if (time === 0) { clearInterval(initTime) //少了這個停損點倒數的數字會變成負的 // 時間到的訊息用字串模板的方式載入 endgameEl.innerHTML = ` &lt;h1&gt;Time ran out&lt;/h1&gt; &lt;p&gt;Your final score is ${score}&lt;/p&gt; &lt;button onclick=\"location.reload()\"&gt;Reload&lt;/button&gt; ` endgameEl.style.display = 'flex' }} 5. 難度選單可以選擇隱藏或是顯示。用 toggle 搭配 css style 就可以了。 123settingsBtn.addEventListener('click', () =&gt; { settings.classList.toggle('hide')}) 6. 刷新頁面後難度不會被回復預設值。要刷新頁面選單的值不會恢復成預設值就會使用到 localStorage ，把選擇的難度寫入到瀏覽器裡面。 選擇難度是一個event，把選到的難度用 setItem 寫到瀏覽器記憶體 localStorage 裡面 再用 difficulty 抓取選到的難度同時判斷輸入單字的時間要多還是要少 到目前為止頁面刷新後難度還是會恢復成預設值，所以要把選單的值寫到 value 裡面 1234567891011121314151617// 1. 選擇難度，把資料寫進瀏覽器記憶體裡面settingsForm.addEventListener('change', (e) =&gt; { difficulty = e.target.value localStorage.setItem('difficulty', difficulty)})// 2. 把選到的值賦予到 difficulty 變數裡面，用來判斷難增加的時間let difficulty = localStorage.getItem('difficulty') !== null ? localStorage.getItem('difficulty') : 'medium'// 3. 這是選完後抓取選單的值，確保頁面刷新後不會恢復成預設值difficultySelect.value = localStorage.getItem('difficulty') !== null ? localStorage.getItem('difficulty') : 'medium' 7. 增加的時間可以依照難度調整獎勵時間。如果難度越高，獎勵時間就越少，反之同理。 12345678// 依照難度調整增加輸入時間if (difficulty === 'hard') { time += 2} else if (difficulty === 'medium') { time += 3} else { time += 5} 功能撰寫 ( jQuery )1. 進入頁面後隨機產生文字。上面 JS 是用 Axios 打 API 獲取資料，jQuery 只能用 AJAX 打 API本來是打 RANDOM USER GENERATOR 的 API，但發現 username 會有其他國家非英文的名字，所以改成打 Word 的 API 獲取單字資料。 AJAX 起手式 :url : 打 API 的網址。method : 拿資料的方法。dataType : 資料的格式。success : 拿到資料後會打要做什麼事。 123456789101112131415function randomUser() { $.ajax({ url: 'https://random-word-api.herokuapp.com/word?number=1', method: 'get', dataType: 'json', success: function (res) { // console.log(res); data = res[0] // console.log(data); $('#word').text(data) }, }) time-- $('#time').val(time)} 2. 比對輸入的值是否吻合再給予獎勵給個分數的初始值，把值設定成 number 型式，判斷書入的值跟單字一樣後會重打一次 API 同時刷新時間，輸入正確後會給獎勵分數。 123456789101112let score = 0$('#text').on('input', function (e) { const textInput = $(this).val() // console.log(textInput); if (textInput === data) { randomUser() updateTime() $('#text').val('') score++ $('#score').text(score) }}) 3. 時間內沒寫完會顯示時間到的訊息。設定時間初始值順便把型別轉成 number。把時間寫入 DOM 元素裡面，當時間到未輸入完單字就會顯示新訊息。 12345678910111213141516let time = 20const initTime = setInterval(updateTime, 1000)function updateTime() { time-- $('#time').text(time + ' s ') if (time === 0) { clearInterval(initTime) $('#end-game-container').html(` &lt;h1&gt;Time ran out&lt;/h1&gt; &lt;p&gt;Your final score is ${score}&lt;/p&gt; &lt;button onclick=\"location.reload()\"&gt;Reload&lt;/button&gt; `) $('#end-game-container').css('display', 'flex') }} 4. 難度選單可以選擇隱藏或是顯示。用 toggleClass 可以顯示或是隱藏某個元素。 123$('#settings-btn').on('click', () =&gt; { $('#settings').toggleClass('hide')}) 5. 刷新頁面後難度不會被回復預設值。難度選完後不要恢復成預設值的方法就是把資料寫進瀏覽器記憶體裡面，寫入後每次更換難度都會刷新一次頁面。 123456789101112$('#difficulty').change(function () { difficulty = $('#difficulty').val() console.log(difficulty) localStorage.setItem('difficulty', difficulty) location.reload()})$('#difficulty').val( localStorage.getItem('difficulty') !== null ? localStorage.getItem('difficulty') : 'medium') 參考資料Axios20 Web Projects With Vanilla JavaScript談談 JavaScript 的 setTimeout 與 setIntervalRANDOM USER GENERATOR","link":"/2021/01/29/typingGmae/"},{"title":"Vue - 動態綁定及監聽","text":"v-bindv-bind 指令是用來把一個數值綁定到 HTML 屬性上，因為到後期會大量用到，所以會使用縮寫 “ : “ 用 v-bind 製作一個簡單的按鈕123456789101112&lt;div id=\"app\"&gt; &lt;button :type=\"selected\"&gt;selected&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { selected: 'submit', }, })&lt;/script&gt; codePen 透過 v-bind 可以將 submit 這個值綁到 type 屬性上 v-onv-on 縮寫為 “@”，用來偵聽 DOM 輸入的事件並改變資料 製作一個簡單的按鈕123456789101112131415161718&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" :checked=\"selected\" /&gt; &lt;button @click=\"toggle\"&gt;toggle&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { selected: false, }, methods: { toggle() { this.selected = !this.selected }, }, })&lt;/script&gt; codePen checked 屬性是控制 input 著 checkbox 有沒有被勾選到，而 selected 這個值是代表 data 裡面的 selected ，要讓 selected 賦予值，就必須要用 v-bind 動態綁定到 checked 屬性上，再透過 v-on 偵聽事件綁定 selected。 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/07/v-bind%20%E5%8F%8A%20v-on%20%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Vue - 判斷式","text":"v-ifCodePen我想透過勾選來決定要不要顯示 h1 標籤的內容，顯用 v-model 綁定屬性，再用 v-if 判斷決定與否 12345678910111213&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" v-model=\"checked\" /&gt; &lt;h1 v-if=\"checked\"&gt;Hello World!&lt;/h1&gt;&lt;/div&gt;&lt;!-- Scss --&gt;&lt;!-- #app{ text-align: center; h1{ font-size: 30px; color: red; }} --&gt; 123456let vm = new Vue({ el: '#app', data: { checked: false, },}) v-if 除了可以用在元素上，也可以用 template 模板包住某些元素 這樣一個一個寫在元素太麻煩，所以改成直接寫在 template 模板上，會有一樣的效果 12345678910&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" v-model=\"checked\" /&gt; &lt;!-- &lt;h1 v-if=\"checked\"&gt;Hello World!&lt;/h1&gt; --&gt; &lt;template v-if=\"checked\"&gt; &lt;h1&gt;html&lt;/h1&gt; &lt;h2&gt;javascript&lt;/h2&gt; &lt;h3&gt;css&lt;/h3&gt; &lt;/template&gt;&lt;/div&gt; 123456let vm = new Vue({ el: '#app', data: { checked: false, },}) 在勾選顯示時，用開發者工具看會顯示 DOM 元素 但是不勾選時，DOM 元素會直接被拿掉而不是用 display:none 隱藏 v-elseCodePen 12345&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" v-model=\"checked\" /&gt; &lt;h1 v-if=\"checked\"&gt;Hello World!&lt;/h1&gt; &lt;h1 v-else&gt;OverWatch&lt;/h1&gt;&lt;/div&gt; 123456let vm = new Vue({ el: '#app', data: { checked: true, },}) 不是 A 就是 B，當 v-if 屬性是 false 時，則會顯示 v-else，而 v-if 跟 v-else 之間不能有任何元素，若出現其他元素 v-else 就不會觸發用開發者工具看，會發現一樣不是透過 display:none 隱藏 v-else-ifCodePen v-if 跟 v-else 是簡單的二元判斷，那v-else-if 是提供兩者之間的選擇，介於 v-if 跟 v-else 之間，同時很多個 v-else-if 也沒關係! 1234567&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" v-model=\"checkedOne\" /&gt; &lt;input type=\"checkbox\" v-model=\"checkedTwo\" /&gt; &lt;h1 v-if=\"checkedOne\"&gt;勾選 checkedOne!&lt;/h1&gt; &lt;h1 v-else-if=\"checkedTwo\"&gt;勾選 checkedTwo&lt;/h1&gt; &lt;h1 v-else&gt;checkedOne、checkedTwo，都不是&lt;/h1&gt;&lt;/div&gt; 1234567let vm = new Vue({ el: '#app', data: { checkedOne: false, checkedTwo: false, },}) 再都不勾選情況下: 勾選 checkedOne: 勾選 checkTwo: 兩個都勾，會顯示 checkedOne 是因為判斷第一個 v-if 已經成立 v-showv-if 是透過刪除 DOM 元素來決定顯示與否，但如果要透過 CSS 的 display:none來控制 並且在不刪除 DOM 情況下，這時就要用 v-show 。 v-show 有兩個地方要特別注意:1. 沒有 v-else 2. 不能用 template 1234&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" v-model=\"checkedOne\" /&gt; &lt;h1 v-show=\"checkedOne\"&gt;勾選 checkedOne!&lt;/h1&gt;&lt;/div&gt; 1234567let vm = new Vue({ el: '#app', data: { checkedOne: false, checkedTwo: false, },}) 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/08/v-if/"},{"title":"Vue - 基本語法( 一 )","text":"簡單介紹 Vue 模板基本語法的使用，包含 : v-bind、mustache 、v-once、v-html、v-text …等等。以下範例皆使用 Vue 2.6.1 版本。 一、插值語法1. mustache在 html 模板中插入 mustache 語法。以下為官方文件的案例。 1&lt;div id=\"app\"&gt;{{message}}&lt;/div&gt; 123456const app = new Vue({ el: '#app', data: { message: ' hello world', },}) codePen 表達式mustache 不只可以寫簡單的變數，還可以寫出簡單的表達式。 12345678910111213&lt;div id=\"app\"&gt; {{message}} &lt;!-- 以下示範簡單的表達式 --&gt; &lt;h2&gt;{{firstName + lastName}}&lt;/h2&gt; &lt;!-- 由於中間名字黏在一起不好看，所以中間加入空格，寫法有兩種 --&gt; &lt;h2&gt;第一種: {{firstName +' '+ lastName}}&lt;/h2&gt; &lt;h2&gt;第二種: {{firstName}} {{lastName}}&lt;/h2&gt; &lt;!-- 計算 --&gt; &lt;h3&gt;計算: {{count * 2}}&lt;/h3&gt;&lt;/div&gt; 123456789const app = new Vue({ el: '#app', data: { message: ' hello world', firstName: 'Tseng', lastName: 'ken', count: 100, },}) codePen 2. v-once這項指令後面不需要填寫任何表達式，而且這指令只會渲染元素或是組件一次，並且不會隨資料改變而改變。 一樣使用官方案例 123&lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt;&lt;/div&gt; 123456const app = new Vue({ el: '#app', data: { message: ' hello world', },}) 但是我們只要在開發者模式下更改 message 變數的資料，裡面的值就會更著改變，如下圖 但是加上 v-once 語法 12345&lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h2 v-once&gt;{{message}}&lt;/h2&gt;&lt;/div&gt;&lt;!-- JS 一樣不變 --&gt; 然後用更改 message 裡面的資料，如下圖可以看到沒有加上 v-once 語法的 message 被改變的，而加上 v-once 的沒有被改變。 Demo 3. v-html有時候在 data 資料裡面會有涵蓋標籤的語法。 1234&lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h3&gt;{{url}}&lt;/h3&gt;&lt;/div&gt; 1234567const app = new Vue({ el: '#app', data: { message: ' hello world', url: '&lt;a href=\"https://www.google.com\"&gt;Google&lt;/a&gt;', },}) 在這樣的狀況下會顯示 要正常顯示就要加上 v-html，意思是要以 html 的型式展示 123456&lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h3&gt;{{url}}&lt;/h3&gt; &lt;h3 v-html=\"url\"&gt;&lt;/h3&gt;&lt;/div&gt; 這樣就可以正常顯示了 不過這指令要小心，因為有很大的機會會有 XSS 攻擊，比較不推薦此種寫法。 DEMO 4. v-text一樣使用官網的案例 之前都是用 mustache 顯示 message 的值，同樣的方式是在標籤上面加上 v-text 不需要 mustache 也一樣可以顯示 1234&lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}&lt;/h2&gt; &lt;h2 v-text=\"message\"&gt;&lt;/h2&gt;&lt;/div&gt; 123456const app = new Vue({ el: '#app', data: { message: 'Hello World', },}) 如下圖 但是這種寫法比較不靈活，如果我們想在後面加入一些字 1234&lt;div id=\"app\"&gt; &lt;h2&gt;{{message}}，你好啊!!&lt;/h2&gt; &lt;h2 v-text=\"message\"&gt;，你好啊!!&lt;/h2&gt;&lt;/div&gt; v-text 會直接覆蓋掉標籤裡面的值，如下圖 DEMO 二、動態綁定在現代網頁中的每個連結或是圖片都是用動態來顯示的，不是寫死的。 1. v-bind可以動態綁定 a 元素的 href img 元素的 src 因為之後會大量使用，所以 v-bind 的語法糖為 “ : “ (冒號) 以前最一開始的寫法是直接在 img 標籤上寫入網址，如下 (圖片來自官網) 1234&lt;div id=\"app\"&gt; {{message}} &lt;img src=\"https://cn.vuejs.org/images/logo.png\" alt=\"\" /&gt;&lt;/div&gt; 顯示如下 但是現在要動態的方式顯示，寫法如下:給 src 屬性動態綁定(v-bind) imgUrl，一旦綁定後 imgUrl 就是變數!!那這變數就會去 vue 實例裡面找他的 value 值，再把 value 值放交給 src 。 12345&lt;div id=\"app\"&gt; {{message}} &lt;!-- &lt;img src=\"https://cn.vuejs.org/images/logo.png\" alt=\"\"&gt; --&gt; &lt;img :src=\"imgUrl\" alt=\"\" /&gt;&lt;/div&gt; 1234567const app = new Vue({ el: '#app', data: { message: 'Hello World', imgUrl: 'https://cn.vuejs.org/images/logo.png', },}) 顯示的效果跟上圖是一樣的。 同樣的換成 a 連結型式 1234567&lt;div id=\"app\"&gt; &lt;!-- 命令式 --&gt; &lt;a href=\"https://www.google.com/\"&gt;寫死的 Google&lt;/a&gt; &lt;!-- 聲明式 --&gt; &lt;a :href=\"linkUrl\"&gt;動態綁定的Google&lt;/a&gt;&lt;/div&gt; 123456const app = new Vue({ el: '#app', data: { linkUrl: 'https://www.google.com/', },}) 雖然顯示結果是一樣的，但在開發網頁的時候不可能把所有連結都寫死在標籤上，而是透過後端伺服器請求資料然後動態綁定在標籤上。 DEMO 2. v-bind 綁定 className上面講完基本連結的動態綁定，接下來要講 className 的用動態綁定。 如果想在某個 className 上加點屬性，從最原始寫法到進階動態綁定的寫法，如下 1234567&lt;div id=\"app\"&gt; &lt;!-- 最原始的 --&gt; &lt;h2 class=\"active\"&gt;{{message}}&lt;/h2&gt; &lt;!-- 動態綁定一 --&gt; &lt;h2 :class=\"active\"&gt;{{message}}&lt;/h2&gt;&lt;/div&gt; 除了以上兩種，再來要綁物件型式的，在 class 後面要綁定的是一個物件，寫法跟對應的值都寫在下面程式碼裡面。 當 className 被判斷為 true 的時候，那 className 的屬性就會被加到 class 裡面，這樣就可以透過控制布林值來決定要不要顯示。 1234567891011&lt;div id=\"app\"&gt; &lt;!--&lt;h2 :class='{key1: value1, key2: value2}'&gt;{{message}}&lt;/h2&gt; --&gt; &lt;!--&lt;h2 :class='{className1: 布林值1, className2: 布林值2}'&gt;{{message}}&lt;/h2&gt; --&gt; &lt;h2 :class=\"{active: true, line: false}\"&gt;{{message}}&lt;/h2&gt;&lt;/div&gt;&lt;style&gt; .active { color: red; }&lt;/style&gt; 123456const app = new Vue({ el: '#app', data: { message: 'Hello World', },}) 如上圖一旦屬性判斷為 true 的時候就顯示。 但是布林值不可能寫在標籤上面，必須要動態綁定。 123&lt;div id=\"app\"&gt; &lt;h2 :class=\"{active: isActive, line: isLine}\"&gt;{{message}}&lt;/h2&gt;&lt;/div&gt; 12345678const app = new Vue({ el: '#app', data: { message: 'Hello World', isActive: true, isLine: true, },}) 如果兩個都為 true 就同時看到兩個 class ( active &amp; line )。 但是現在我可以透過開發者工具來控制。isLine 變成 false 後就不會顯示了。 不過這樣控制顯示結果也點不對，總不可能叫使用者去開發者工具那邊更改吧，所以這例稍微超前一下要用 v-on 來做切換，它是一個監聽的指令。 1234&lt;div id=\"app\"&gt; &lt;h2 :class=\"{active: isActive, line: isLine}\"&gt;{{message}}&lt;/h2&gt; &lt;button v-on:click=\"change\"&gt;Change&lt;/button&gt;&lt;/div&gt; 12345678910111213const app = new Vue({ el: '#app', data: { message: 'Hello World', isActive: true, isLine: true, }, methods: { change() { this.isActive = !this.isActive }, },}) 這樣就可以用按鈕來做動態切換了。 DEMO 參考資料2019 年最全最新 Vue、Vuejs 教程，从入门到精通","link":"/2021/02/22/%E5%9F%BA%E6%9C%AC%E6%A8%A1%E6%9D%BF%E8%AA%9E%E6%B3%95/"},{"title":"JavaScript 實作 - 猜數字","text":"功能敘述 : 猜數字，有固定範圍。 猜錯會告知區間。 如果猜的不是數字會顯示訊息提示。 GithubDemo 模板架構1234567891011&lt;img src=\"img/mic.png\" alt=\"Speak\" /&gt;&lt;h1&gt;請猜一個 1 ~ 100 以內的數字&lt;/h1&gt;&lt;h3&gt;請對麥克風說出一個數字&lt;/h3&gt;&lt;div id=\"msg\" class=\"msg\"&gt; &lt;!-- &lt;div&gt;You said:&lt;/div&gt; &lt;span class=\"box\"&gt;Guessed number&lt;/span&gt; &lt;div&gt;number range&lt;/div&gt; --&gt;&lt;/div&gt; 功能撰寫1. 取隨機數字，限定 1~100 以內Math.random : 隨機產生出 0~1 之間的小數，因為小於 1 ，所以最大是 0.99。Math.floor : 回傳小於等於所給數字的最大整數。 123function getRandomNumber() { return Math.floor(Math.random() * 100) + 1 // +1 範圍才會到 100} 2. 錄製麥克風的聲音SpeechRecognition : 在 Chrome 上使用語音辨識的功能，會把聲音發送到網頁裡面進行識別處理，要注意的是不能離線工作。 1234window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognitionlet recognition = new window.SpeechRecognition() 3. 錄製聲音時會觸發條件result : 當事件觸發後會將值回傳，但值如果是 undefined，就沒辦法回傳 12recognition.start()recognition.addEventListener('result', onSpeak) 4. 觸發後抓取文字當使用者說出文字後，經過網頁處裡會得到一個文字的 value ，這 value 值會顯示在 results 陣列裡面，用 console 查看 e.results 如下圖。value 的 key 為 transcript 。 再用 callback function 的方式，將函示切分方便管理。 123456function onSpeak(e) { const msg = e.results[0][0].transcript writeMsg(msg) checkMsg(msg)} 5. 將文字顯示在 DOM 上123456function writeMsg(msg) { msgEl.innerHTML = ` &lt;div&gt;You said: &lt;/div&gt; &lt;span class=\"box\"&gt;${msg}&lt;/span&gt; `} 6. 判斷錄製的文字是否符合標準為防止說的不是數字或是大於區間，需要寫一點防範機制，如果使用者說了數字沒有答對，就要給點提示，讓使用者有方向。 只能是數字 只能在區間內 提示數字要高還是低，讓使用者知道方向 123456789101112131415161718192021222324252627function checkMsg(msg) { // 主換數字型別 const num = +msg // 判斷說的是不是數字 if (Number.isNaN(num)) { msgEl.innerHTML = `&lt;div&gt;請說數字 !&lt;/div&gt;` } // 判斷數字區間 if (num &gt; 100 || num &lt; 1) { msgEl.innerHTML = `&lt;div&gt;數字只能介於 1~100 之間&lt;/div&gt;` } // 開始猜測，決定數字要喊高還是喊低 if (num === randomNumber) { document.body.innerHTML = ` &lt;h2&gt;恭喜猜中! &lt;br&gt;&lt;br&gt; 就是 ${num}&lt;/h2&gt; &lt;button class=\"play-again\" id=\"play-again\"&gt;再玩一次&lt;/button&gt; ` } else if (num &gt; randomNumber) { msgEl.innerHTML = `&lt;div&gt;再低&lt;/div&gt;` } else { msgEl.innerHTML = `&lt;div&gt;再高&lt;/div&gt;` }} 7. 再挑戰一次一旦挑戰成功後，為了讓使用者可以在挑戰一次。將網頁刷新一次就可以了。因為 btn 是用字串模板的方式載入的，所以不能用選擇器綁 DOM 元素，但可以用按鈕 id 的方式來識別。 12345document.body.addEventListener('click', (e) =&gt; { if (e.target.id === 'play-again') { window.location.reload() }}) 參考資料SpeechRecognition: result eventSpeechRecognition20 Web Projects With Vanilla JavaScript","link":"/2021/02/01/%E7%8C%9C%E6%95%B8%E5%AD%97/"},{"title":"JavaScript 實作 - 記帳簿","text":"功能描述:輸入記帳名稱並計算該物品的價格。 GithubDEMO HTML 模板給個容器，並將顯示及輸入的內容寫在裡面，比較特別的地方是 list ，list 裡面的項目清單會交由 JavaScript 字串模板來撰寫 123456789101112131415161718192021222324252627282930313233343536373839&lt;h2&gt;Expense Tracker&lt;/h2&gt;&lt;div class=\"container\"&gt; &lt;h4&gt;Your Balance&lt;/h4&gt; &lt;h1 id=\"balance\"&gt;$0.00&lt;/h1&gt; &lt;div class=\"inc-exp-container\"&gt; &lt;div&gt; &lt;h4&gt;Income&lt;/h4&gt; &lt;p id=\"money-plus\" class=\"money plus\"&gt;+$0.00&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h4&gt;Expense&lt;/h4&gt; &lt;p id=\"money-minus\" class=\"money minus\"&gt;-$0.00&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;h3&gt;History&lt;/h3&gt; &lt;ul id=\"list\" class=\"list\"&gt; &lt;!-- &lt;li class=\"minus\"&gt; Cash &lt;span&gt;-$400&lt;/span&gt;&lt;button class=\"delete-btn\"&gt;x&lt;/button&gt; &lt;/li&gt; --&gt; &lt;/ul&gt; &lt;h3&gt;Add new transaction&lt;/h3&gt; &lt;form id=\"form\"&gt; &lt;div class=\"form-control\"&gt; &lt;label for=\"text\"&gt;Text&lt;/label&gt; &lt;input type=\"text\" id=\"text\" placeholder=\"Enter text...\" /&gt; &lt;/div&gt; &lt;div class=\"form-control\"&gt; &lt;label for=\"amount\" &gt;Amount &lt;br /&gt; (negative - expense, positive - income)&lt;/label &gt; &lt;input type=\"number\" id=\"amount\" placeholder=\"Enter amount...\" /&gt; &lt;/div&gt; &lt;button class=\"btn\"&gt;Add transaction&lt;/button&gt; &lt;/form&gt;&lt;/div&gt; CSS 樣式要注意的是 plus、minus 樣式，因為這兩個樣式會透過 JavaScript 的函式來控制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151@import url('https://fonts.googleapis.com/css?family=Lato&amp;display=swap');:root { --box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);}* { box-sizing: border-box;}body { background-color: #f7f7f7; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; font-family: 'Lato', sans-serif;}.container { margin: 30px auto; width: 350px;}h1 { letter-spacing: 1px; margin: 0;}h3 { border-bottom: 1px solid #bbb; padding-bottom: 10px; margin: 40px 0 10px;}h4 { margin: 0; text-transform: uppercase;}.inc-exp-container { background-color: #fff; box-shadow: var(--box-shadow); padding: 20px; display: flex; justify-content: space-between; margin: 20px 0;}.inc-exp-container &gt; div { flex: 1; text-align: center;}.inc-exp-container &gt; div:first-of-type { border-right: 1px solid #dedede;}.money { font-size: 20px; letter-spacing: 1px; margin: 5px 0;}.money.plus { color: #2ecc71;}.money.minus { color: #c0392b;}label { display: inline-block; margin: 10px 0;}input[type='text'],input[type='number'] { border: 1px solid #dedede; border-radius: 2px; display: block; font-size: 16px; padding: 10px; width: 100%;}.btn { cursor: pointer; background-color: #9c88ff; box-shadow: var(--box-shadow); color: #fff; border: 0; display: block; font-size: 16px; margin: 10px 0 30px; padding: 10px; width: 100%;}.btn:focus,.delete-btn:focus { outline: 0;}.list { list-style-type: none; padding: 0; margin-bottom: 40px;}.list li { background-color: #fff; box-shadow: var(--box-shadow); color: #333; display: flex; justify-content: space-between; position: relative; padding: 10px; margin: 10px 0;}.list li.plus { border-right: 5px solid #2ecc71;}.list li.minus { border-right: 5px solid #c0392b;}.delete-btn { cursor: pointer; background-color: #e74c3c; border: 0; color: #fff; font-size: 20px; line-height: 20px; padding: 2px 5px; position: absolute; top: 50%; left: 0; transform: translate(-100%, -50%); opacity: 0; transition: opacity 0.3s ease;}.list li:hover .delete-btn { opacity: 1;} JavaScript所有互動將從這邊開始撰寫，也算是重頭戲! 1. 首先抓取 DOM 元素並設定成變數1234567const balance = document.querySelector('#balance')const moneyPlus = document.querySelector('#money-plus')const moneyMinus = document.querySelector('#money-minus')const list = document.querySelector('#list')const text = document.querySelector('#text')const form = document.querySelector('#form')const amount = document.querySelector('#amount') 2. 新增 DOM list 項目清單為了方便測試先寫一個陣列的假資料 123456789const dummyTransactions = [ { id: 1, text: 'Flower', amount: -20 }, { id: 2, text: 'Salary', amount: 300 }, { id: 3, text: 'Book', amount: -10 }, { id: 4, text: 'Camera', amount: 150 },]// 將假資料暫時帶入 transaction 變數裡面let transactions = dummyTransactions 接著撰寫新增 list 項目清單，因為在撰寫項目清單時不確定會有幾個，因此在這邊用字串模板的方式載入，為了要載入新的項目必須要創建新的元素，這時候可以用 createElement 的方式來新增，新增好後要透過輸入的值來判斷是正還是負，這樣可以連帶綁定 css 樣式的顏色，最後利用字串模板的方式來顯示項目，不果字串模板裡面已經有判斷正負號了，所以後面的值就用 Math.abs 取絕對值的方式來顯示。 步驟如下: 新增函式 判斷正負號 新增項目元素，同時賦予到 item 變數上 判斷 item 輸入的值決定要綁定的顏色 用字串模板的方式將值賦予到 item 再將 item 透過 appendChild 的方式塞到 list 元素裡面 123456789101112131415161718function addTransactionDOM(transaction) { // 判斷正負值 const sign = transaction.amount &gt; 0 ? '+' : '-' // console.log(sign) // 新增 li 元素 const item = document.createElement('li') // console.log(item) // 將 className 新增到 item ，判斷顯示的顏色 item.classList.add(transaction.amount &gt; 0 ? 'plus' : 'minus') // removeTransaction 要綁id ，不然會刪到同名的 item.innerHTML = `${transaction.text}&lt;span&gt;${sign}${Math.abs( transaction.amount )}&lt;/span&gt;&lt;button&gt;X&lt;/button&gt;` list.appendChild(item)} 3. 初始化每當執行完某些動作時，都要將值初始化 forEach :會將陣列中每個元素套用到指定的函式裡進行運算。 1234567891011function init() { // 輸入完之後 list 要回復空值 list.innerHTML = '' // 將假資料丟到 addTransactionDOM 函式裡面運算 transactions.forEach(addTransactionDOM) updateValue()}init() // 執行 4. 監聽 form 表單內輸入的值接下來要判斷表單內輸入的值是否正確，如果輸入正確，將值同時綁定到 key 上，這麼做是為了防止刪除到同名的項目，像是用身分證綁定每筆資料的概念。 首先利用 callbakc function 的方式將函式賦予到 addTransaction 參數上，再用 if 判斷式判斷輸入的值是否為空值，如果不是空值，將輸入的值綁定到物件的 key 上，同時執行個兩函式 將 transaction 變數新增到陣列清單裡面(這邊暫時用假資料的陣列) 將 transaction 帶到 addTransactionDOM 函式執行 然後再將輸入框的值清空 Math.floor :將有小數的值取成整數Math.random :取亂數，建立變數的身分證 步驟 監聽表單元素 判斷輸入值同時將輸入的值用 id 綁定 同時執行三的動作，將值新增到陣列內、判斷輸入值得正負、將值清空 12345678910111213141516171819202122232425262728293031323334function addTransaction(e) { e.preventDefault() // 先判斷輸入是否為空值，若不是則繼續執行 if (text.value === '' || amount.value === '') { alert('請重新輸入') } else { // 如果不是空值，將輸入的 value 帶入 key 裡 const transaction = { id: generateID(), text: text.value, amount: +amount.value, //前面的+是為了轉成 number 型別 } // 將新增的 transaction 物件加入到 transactions 物陣列內 transactions.push(transaction) // 執行 addTransactionDOM 函式，並帶入transaction addTransactionDOM(transaction) // 執行帶值跟計算 updateValue() updateLocalStorage() // 輸入完後恢復空值 text.value = '' amount.value = '' }}function generateID() { return Math.floor(Math.random() * 1000000)}form.addEventListener('submit', addTransaction) 5. 計算收入與支出以上判斷值的正確性跟顯示的樣式都寫好了，接下來要計算輸入的值將 transaction 帶到 transaction.amount 裡面，再用 map 計算，判斷陣列內值，再將值賦予到 amounts 變數裡面，透過 amounts 變數去計算總結、收入、支出的值。 算好後將計算的值賦予到 DOM 元素上這樣就可以顯示計算的值了。 acc 是計算出來的總值， item 是每次新增的每一筆資料。 map :處理陣列中每個元素，最後回傳出一個新的陣列。 filter :會將陣列中的「每一個」元素帶入指定的函式內做判斷，如果元素符合判斷條件則會產生新的陣列元素。 reduce :將陣列中每個元素進行計算，每次計算的結果會再與下個元素作計算，直到結束為止。 12345678910111213141516171819202122function updateValue() { const amounts = transactions.map((transaction) =&gt; transaction.amount) // 計算總結 const total = amounts.reduce((acc, item) =&gt; (acc += item), 0).toFixed(2) // 計算收入 const income = amounts .filter((item) =&gt; item &gt; 0) .reduce((acc, item) =&gt; (acc += item), 0) .toFixed(2) // 計算支出 const expense = amounts.filter((item) =&gt; item &lt; 0).reduce((acc, item) =&gt; (acc += item), 0) * -1 // 將 total、income、expense 塞到各 dom 裡面 balance.innerHTML = `${total}` moneyPlus.innerHTML = `${income}` moneyMinus.innerHTML = `${expense}`} 6. 移除輸入的值如果有新增的項目不要了，那就會用到刪除，刪除的函式是認剛才綁定的 id 就是陣列的身分證，觸發條件是當我 onclick 的時候就可以移除剛該筆項目。 在剛才的 addTransactionDOM 裡面有個字串模板，因為項目是在這邊創建的，那刪除也一起寫在這，透過 removeTransaction 函式綁定 id 12345item.innerHTML = `${transaction.text}&lt;span&gt;${sign}${Math.abs(transaction.amount)}&lt;/span&gt;&lt;button class='delete-btn' onclick='removeTransaction(${transaction.id})'&gt;X&lt;/button&gt;` 刪除的函式 123456789function removeTransaction(id) { //記得帶 id 參數，不然會 fail //邏輯?? transactions = transactions.filter((transaction) =&gt; transaction.id !== id) // 刪除後重新儲存在本地端 updateLocalStorage() init()} 7. 將計算的歷史紀錄保存起來，並存在本地端因為要要記錄自己新增的每筆資料，所以之前代替用的假資料可以刪掉了 Storage.setItem('key', 'value')：透過在 setItem() 方法中指定物件屬性的 key 以及 value ，我們可以在 storage 物件中加入屬性或修改原本的屬性內容。 2. Storage.getItem('key')：透過在 getItem() 方法中輸入屬性的 key ，我們可以得到 storage 物件對應的屬性 value 。 利用 getItem 將 transactions 的 key 值輸入到 localStorage 裡面，再利用 JSON.parse 將值轉成物件格式，然後在賦予到 localStorageTransactions 變數中 如果 localStorage 抓到的值是 null 會自動轉換成空值 123456const localStorageTransactions = JSON.parse( localStorage.getItem('transactions'))let transactions = localStorage.getItem('transactions') !== null ? localStorageTransactions : [] 利用 setItem 的方式將 transactions 設定成 key ，將 transactions 透過 JSON.stringify 的方式轉成字串並設定成 value ，加到 addTransaction、removeTransaction 函式裡面，這樣在新增每筆資料的時候不只同時綁定 id 還記錄到了本地端的歷史紀錄裡面。 123function updateLocalStorage() { localStorage.setItem('transactions', JSON.stringify(transactions))} 參考資料JS30-Day15-LocalStorageJavaScript Array 陣列操作方法大全 ( 含 ES6 )20 Web Projects With Vanilla JavaScript","link":"/2021/01/13/%E8%A8%98%E5%B8%B3/"},{"title":"Vue - 語法修飾","text":"防止預設事件發生: preventDefaulta 連結預設是開新分頁，但我想要點 a 連結就跳出 alert 同時又不要開新的分頁，這時候就要用 preventDefault 。先偵聽一個事件 linkClick ，並給 linkClick 一個函式，點擊 a 連結時為了要取消預設行為 ( 開新分頁 )，所以在函式內新增 e.preventDefault()。 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;a href=\"https://www.google.com/\" target=\"_blank\" @click=\"linkClick\"&gt; google &lt;/a&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: {}, methods: { linkClick(e) { e.preventDefault() alert('不開新頁面') }, }, })&lt;/script&gt; DEMO 這個方法會常常用在 form submit 上，因為原本預設行為是透過網頁讀取並取得網址資源，但我們會希望網頁不要重新讀取同時又可以取得網頁資源，這時就可以在 form 裡面呼叫 e.preventDefault() 。 方法二：精簡寫法，直接在 click 後面加上 prevent 就結束了。 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;a href=\"https://www.google.com/\" target=\"_blank\" @click.prevent=\"linkClick\"&gt; google &lt;/a&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: {}, methods: { linkClick() { alert('不開新頁面') }, }, })&lt;/script&gt; codepen 防止子元件連動: stop、 self123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;div class=\"box\" @click=\"msg = 'c'\"&gt; &lt;div class=\"box\" @click=\"msg = 'b'\"&gt; &lt;div class=\"box\" @click=\"msg = 'a'\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;h1&gt;{{msg}}&lt;/h1&gt;&lt;/div&gt;&lt;style&gt; .box { display: inline-block; min-width: 100px; min-height: 100px; padding: 30px; border: 3px solid red; }&lt;/style&gt;&lt;script&gt; new Vue({ el: '#app', data: { msg: '', }, })&lt;/script&gt; DEMO 當我點擊最裡面正方形的時候會出現 c 而不是 a，原因是最裡面的 box 是最外面 box 的 children ，所以一旦點擊最裡面的 box 就會一層一層往上找到最外層的 box 。這時候就可以在 click 後面加上 stop 或是 self 來防止事件往上層找。 1. stop 是調用 event.stopPropagation() ，防止事件往上一層傳。 2. self 只當事件是從偵聽器綁定的元素本身觸發時才觸發回調，就是只有自己本身發出的不然不會觸發事件。假設 div 包了 100 層，事件是點擊第 2 層才會觸發，那就算我點擊外面第 1 層或是裡面的 3~100 層都是不會觸發的。 範例如下： 123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;div class=\"box\" @click.self=\"msg = 'c'\"&gt; &lt;div class=\"box\" @click.self=\"msg = 'b'\"&gt; &lt;div class=\"box\" @click.stop=\"msg = 'a'\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;h1&gt;{{msg}}&lt;/h1&gt;&lt;/div&gt;&lt;style&gt; .box { display: inline-block; min-width: 100px; min-height: 100px; padding: 30px; border: 3px solid red; }&lt;/style&gt;&lt;script&gt; new Vue({ el: '#app', data: { msg: '', }, })&lt;/script&gt; codepen 參考資料: 官方文件參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/20/%E8%AA%9E%E6%B3%95%E4%BF%AE%E9%A3%BE/"},{"title":"JavaScript - Hoisting 提升","text":"今天看到澎澎的教學影片，覺得觀念清晰好懂，就紀錄一下這重要觀念。 在 JavaSctip 裡面如果故意把宣告變數擺在最後面，它仍就會因為 Hoisting 的效果被放到最前面。( 注意我只說宣告變數 ( var a )，沒說變數賦值 ( a = 10 ) ) 變數的 Hoisting先來看看最基本的變數宣告把值賦予到 a 變數上，然後在印出來。 12var a = 10 //宣告變數+變數賦值console.log(a) //10 看起來沒甚麼很正常的顯示 如果我把宣告變數移到下面的話會顯示甚麼? 12console.log(a)var a = 10 //undefined 會顯示 undefined 。 為什麼會這樣? 因為 JavaScript 的特性，變數的宣告會提升 ( Hoisting )，所以當瀏覽器在讀取程式碼時，會變成下面這樣。 1234//這是瀏覽器讀取後的var a //宣告變數console.log(a) //undefineda = 10 //變數賦值 undefined 的意思就是我已經宣告這個變數了，但是變數沒有被賦值，所以會顯示 undefined。 那在換個寫法，宣告 跟 賦值 下上對調。 123a = 10 //變數賦值console.log(a) //10var a //宣告變數 這樣可以讀到值，為什麼? 因為 JavaScript 的特性，變數的宣告會提升 ( Hoisting )，所以當瀏覽器在讀取程式碼時，會變成下面這樣。 1234//這是瀏覽器讀取後的var a //宣告變數a = 10 //變數賦值console.log(a) //10 不過宣告跟賦值下上對調這樣的寫法在一般開發過程中是不被允許的，正常情況下，當我們在使用某個變數之前一定要先宣告變數，這是必須養成的好習慣。 DEMO 函式的 Hoisting上面講變數的宣告，接下來講函式的宣告。 1. 陳述式先宣告一個陳述式的函式再呼叫。 12345function fn(){ //宣告函式 console.log('Hello') //Hello}fn() //呼叫函式 會正常印出來。 但如果我把 fn() 宣告挪到函式前面的話呢? 1234fn()function fn(){ console.log('Hello') //Hello} 一樣可以正常顯示，為甚麼?因為函式的宣告等同於上面變數的宣告，會因為 JavaScript Hoisting 的特性被移到最上方。 2. 表達式上面的宣告是陳述式，那改成表達式呢? 1234fn()var fn = function(){ console.log('Hello') // fn is not a function } 會顯示 fn is not a function ，上面這段在瀏覽器讀取程式碼的時候會變成下面這樣。 12345var fn fn()fn = function(){ console.log('Hello') // fn is not a function } 為了讓比對更清楚我把變數的跟這個函式例子放一起。 1234567var fn // var afn() // console.log(a)fn = function(){ // a = 10 console.log('Hello') } 會發現只有變數的宣告被提升，但沒有被賦值，所以在執行的時候就讀不到資料。 DEMO 參考資料JavaScript 網頁前端工程入門：Hoisting 宣告提升 By 彭彭","link":"/2021/03/27/Hoisting/"},{"title":"JavaScript 實作 - 電影訂位","text":"功能 上方可以選擇要看的電影 選取位子同時計算電影價格 完成圖 GithubDEMO HTMLHTML 結構分成以下幾點: 1. 下拉選單可以選擇電影123456789&lt;div class=\".movieContainer\"&gt; &lt;label&gt;Pick a movie:&lt;/label&gt; &lt;select id=\"movie\"&gt; &lt;option value=\"10\"&gt;Avengers: Endgame ($10)&lt;/option&gt; &lt;option value=\"12\"&gt;Joker ($12)&lt;/option&gt; &lt;option value=\"8\"&gt;Toy Story 4 ($8)&lt;/option&gt; &lt;option value=\"9\"&gt;The Lion King ($9)&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 2. 告示座位狀態圖1234567891011121314&lt;ul class=\"showcase\"&gt; &lt;li&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;small&gt;N/A&lt;/small&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=\"seat selected\"&gt;&lt;/div&gt; &lt;small&gt;Selected&lt;/small&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=\"seat occupied\"&gt;&lt;/div&gt; &lt;small&gt;Occupied&lt;/small&gt; &lt;/li&gt;&lt;/ul&gt; 3. 點選尚未選擇、已選擇的跟可以選擇的座位123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;div class=\"container\"&gt; &lt;div class=\"screen\"&gt;&lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;div class=\"seat\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 4. 顯示選擇的座位數量跟電影票價123456&lt;p class=\"text\"&gt; You have selected &lt;span id=\"count\"&gt;0&lt;/span&gt; seats for a price of $ &lt;span id=\"total\"&gt;0&lt;/span&gt;&lt;/p&gt; 完成的結構圖如下: 樣式載入字體 @import url('https://fonts.googleapis.com/css?family=Lato&amp;display=swap'); 依照 HTML 結構來增加樣式 1. 全域設定移到視窗正中央 123456789101112131415* { box-sizing: border-box;}body { background-color: #242333; color: #fff; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; font-family: 'Lato', sans-serif; margin: 0;} 2. 給選單樣式1234567891011121314.movieContainer { margin: 20px 0; select { background-color: #fff; border: 0; border-radius: 5px; font-size: 14px; margin-left: 10px; padding: 5px 15px 5px 15px; -moz-appearance: none; -webkit-appearance: none; appearance: none; }} 3. 座位樣式12345678910111213141516.seat { background-color: #444451; height: 12px; width: 15px; margin: 3px; border-top-left-radius: 10px; border-top-right-radius: 10px;}.container { perspective: 1000px; margin-bottom: 30px; .row { display: flex; }} 4. 屏幕樣式12345678.screen { background-color: #fff; height: 70px; width: 100%; margin: 15px 0; transform: rotateX(-45deg); box-shadow: 0 3px 10px rgba(255, 255, 255, 0.7);} 5. 選擇座位數量跟票價的樣式123456p.text { margin: 5px 0; span { color: #6feaf6; }} 6. 排列一下座位12345678910111213141516171819202122.showCase { background: rgba(0, 0, 0, 0.1); padding: 5px 10px; border-radius: 5px; color: #777; list-style-type: none; display: flex; justify-content: space-between; &amp;.seat:not(.occupied):hover { cursor: default; transform: scale(1); } li { display: flex; align-items: center; justify-content: center; margin: 0 10px; small { margin-left: 2px; } }} 7. 排列電影座位因為是 scss 寫法所以寫在 seats 裡面 123456789101112131415161718192021222324.seat { background-color: #444451; height: 12px; width: 15px; margin: 3px; border-top-left-radius: 10px; border-top-right-radius: 10px; &amp;.selected { background-color: #6feaf6; } &amp;.occupied { background-color: #fff; } &amp;:nth-of-type(2) { margin-right: 18px; } &amp;:nth-last-of-type(2) { margin-left: 18px; } &amp;:not(.occupied):hover { cursor: pointer; transform: scale(1.2); }} 以上切版就算完成了~ JavaScript接下來要進行 JavaScript 事件的撰寫 1. 抓取 DOM 元素用選擇器抓取 dom 元素，在賦值到各個變數上，會使用 const 是因為此變數之後不能在更動。 12345const container = document.querySelector('.container')const seats = document.querySelectorAll('.row .seat:not(.occupied)')const count = document.querySelector('#count')const total = document.querySelector('#total')const movieSelect = document.querySelector('#movie') 2. 選擇座位時觸發的事件當點擊座位時會先判斷 class 是否有 seat 同時不包含 occupied 的，再用 contains 讓值變成布林值，如果回傳 true 就會用 toggle 增加 selected 屬性，這樣當我們選擇座位時就會更改樣式了。 下面再放一個 updateSelectCount 函式，在我們更動座位時就會觸發。 123456789101112// 監聽容器內座位數值的變化container.addEventListener('click', (e) =&gt; { if ( e.target.classList.contains('seat') &amp;&amp; !e.target.classList.contains('occupied') ) { e.target.classList.toggle('selected') updateSelectCount() }})// 執行updateSelectCount() 3. 計算座位數量跟電影票價當我們選擇座位的時候同時計算座位數量跟電影價格，再將數量跟價格賦予到 DOM 元素裡面。利用 querySelectorAll 把 .row .seat.selected 選起來，再以陣列的方式傳回，用 console.log(selectedSeats) 會看到下圖 有了陣列後就可以計算數量，用 console.log(selectedSeatCount) 可以看到選擇的數量，例如我選 4 個座位 再把選擇座位的數量賦予到 count DOM 元素裡面，就是最下面會顯示的座位數量，再利用這數量去計算票價後，賦直到 total 裡面。 ticketPrice 會用 + 號的原因是要將字串轉成數字型式 這段程式碼如下: 1234567891011let ticketPrice = +movieSelect.value// 計算選擇的座位數量價格function updateSelectCount() { // 將所選取到的座位塞入 selectedSeats 這個變數中 const selectedSeats = document.querySelectorAll('.row .seat.selected') const selectedSeatCount = selectedSeats.length count.innerText = selectedSeatCount // 將選到的座位數量塞到 count 裡面 total.innerText = selectedSeatCount * ticketPrice // 計算座位數量跟票價} 4. 選擇電影同時計算票價這函式是為了當我們在切換電影的時候，重新計算座位跟票價。 在選擇電影的時候就會觸發，計算當下所選的電影價格，再將電影的索引跟選擇的價格放到 setMovieData callback function 裡面，同時更新座位數量跟票價。 +e.target.value 前面的 + 為了確保是數字型別。 1234567891011// 依照選擇的電影變更價格movieSelect.addEventListener('change', (e) =&gt; { ticketPrice = +e.target.value // 查看我們選擇的電影索引跟價格 // console.log(e.target.selectedIndex, e.target.value) setMovieData(e.target.selectedIndex, e.target.value) // 將電影索引跟價格的參數塞到 setMovieData 裡面 updateSelectCount() //執行}) 到目前為止，我們已經完成選擇座位的數量跟票價的計算。接下來要進入到 localStorage 裡面進行設定，因為目前以目前的成是馬刷新頁面，資料就會不見，所以要記錄到瀏覽器的資料庫裏面。 5. 將資料紀錄到瀏覽器的數據庫裡面這麼做的原因是防止我們刷新頁面的時候剛才所選的資料全部都消失，這時候就會用到 localStorage、setItem、getItem、JSON.parse 等觀念。 上段 movieSelect 函式是在監聽選擇電影價格跟位字的索引，當我們在選擇座位或是電影的同時就會觸發到 setMovieData 函式，而 setMovieData 函式帶入的那兩個值就是要記錄到瀏覽器資料庫裡面的參數。 localStorage如果想把資料存在瀏覽器的資料庫裡裡面就會用到 localStorage，但要注意的是 localStorage 會只接受字串，所以要將資料轉成字串 (string) 的型式。 課程中有使用到 ES6 解構語法，將所選擇的座位 selectedSeats 變成陣列，再利用 map 語法處理陣列中的每個元素，然後回傳出新的值。 map: (第一個是每個元素的值 ( 必填 )，第二個是當前元素的索引值 ( 選填 )，第三個是當前的陣列 ( 選填 )) indexOf: 會判斷陣列中是否包含某個值，判斷的方式為「由左而右」，如果有包含就回傳這個值在陣列中的索引值 這段函式的意思是當我選擇了座位 selectedSeats ，將這些選擇的座位化成陣列型式[...selectedSeats] ，再把陣列內的座位拿去判斷 (indexOf) 索引值再回傳，如果找不到索引值就會顯示 -1。 用 console 查看，當我選擇了第 1、第 2 跟第 7 個座位就會顯示索引值跟陣列。 而此段函式要放到 updateSelectCount 函式中，這樣再選取座位的時候就會把索引值傳存到 localStorage 裡面。 12// 將[...selectedSeats]解構的值塞到函式裡面運算，再把結果 return 出來const seatsIndex = [...selectedSeats].map((seat) =&gt; [...seats].indexOf(seat)) setItem當我們將資料設定到瀏覽器數據庫裡面時，這個設定就是 setItem ，寫法是這樣 setItem('key', value)key 值就像是我們在填寫表單的時候會有姓名、年紀、電話這些的開頭value 值就是依照表單中的開頭依序填寫的內容，如: ken、100 歲、0910xxxxx 在 setMovieData 函式中我們將座位索引的 key 設定成 selectedMovieIndex， value 設定成 movieIndex，同理，價格也是這樣設定，目的是將資料存入 localStorage 裡面。 1234567// 透過 localStorage 抓取電影索引值跟價格function setMovieData(movieIndex, moviePrice) { localStorage.setItem('selectedMovieIndex', movieIndex) localStorage.setItem('selectedMoviePrice', moviePrice)}localStorage.setItem('selectedSeats', JSON.stringify(seatsIndex)) getItem用 setItem 設定好 key 跟 value 的值後，要將 value 值取出的話就要用 getItem 抓 key 值。 1localStorage.getItem('selectedSeats') JSON.parse因為 localStorage 只能讀字串型式的資料，所以當我們在讀取或是抓取資料的時候必須是物件的型式，這時就會用到 JSON.parse。 1const selectedSeats = JSON.parse(localStorage.getItem('selectedSeats')) 6. populateUI function在選好座位數量並透過 setIetm 存放到 localStorage 資料庫裡面，現在要使用這些資料，所以會先用 getItem 抓取，然後在轉成物件格式，轉物件是因為資料如果是字串會抓不到，轉完之後在賦值到 selectedSeats 變數裡面 接下來就用selectedSeats變數來判斷是不是空值同時數量又必須大於 1，如果回傳的是 true ，再用 forEach 運算 seats 裡的每個參數，看看選擇的值是否都大於-1，因為陣列第一個值為 0，如果回傳 true ，再將 className 添加到 seat 裡面。 執行 populateUI 函式時也會同時執行另一項函式，剛才已經把電影的索引值設定好並丟到 localStorage 裡面，當我們在選擇電影時會先判斷我們選擇的是否是空值，如果不是就將這項索引值賦予到 movieSelect 函式裡。 forEach: 會將陣列中每個元素套用到指定的函式裡進行運算 12345678910111213141516171819// 紀錄資料，刷新後記錄仍然在function populateUI() { // 因為剛才是轉成字串，這裡要轉成物件 const selectedSeats = JSON.parse(localStorage.getItem('selectedSeats')) if (selectedSeats !== null &amp;&amp; selectedSeats.length &gt; 0) { seats.forEach((seat, index) =&gt; { if (selectedSeats.indexOf(index) &gt; -1) { seat.classList.add('selected') } }) } const selectedMovieIndex = localStorage.getItem('selectedMovieIndex') if (selectedMovieIndex !== null) { movieSelect.selectedIndex = selectedMovieIndex }}// 執行populateUI() 完整程式碼1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const container = document.querySelector('.container')const seats = document.querySelectorAll('.row .seat:not(.occupied)')const count = document.querySelector('#count')const total = document.querySelector('#total')const movieSelect = document.querySelector('#movie')let ticketPrice = +movieSelect.value// 計算選擇的座位數量價格function updateSelectCount() { // 將所選取到的座位塞入 selectedSeats 這個變數中 const selectedSeats = document.querySelectorAll('.row .seat.selected') const selectedSeatCount = selectedSeats.length count.innerText = selectedSeatCount // 將選到的座位數量塞到 count 裡面 total.innerText = selectedSeatCount * ticketPrice // 計算座位數量跟票價 // 將[...selectedSeats]解構的值塞到函式裡面運算 const seatsIndex = [...selectedSeats].map((seat) =&gt; [...seats].indexOf(seat)) localStorage.setItem('selectedSeats', JSON.stringify(seatsIndex))}// 依照選擇的電影變更價格movieSelect.addEventListener('change', (e) =&gt; { ticketPrice = +e.target.value // 查看我們選擇的電影索引跟價格 // console.log(e.target.selectedIndex, e.target.value) // 將電影索引跟價格的參數塞到 setMovieData 裡面 setMovieData(e.target.selectedIndex, e.target.value) updateSelectCount() //執行})// 透過 localStorage 抓取電影索引值跟價格function setMovieData(movieIndex, moviePrice) { localStorage.setItem('selectedMovieIndex', movieIndex) localStorage.setItem('selectedMoviePrice', moviePrice)}// 紀錄資料，刷新後記錄仍然在function populateUI() { // 因為剛才是轉成字串，這裡要轉成物件 const selectedSeats = JSON.parse(localStorage.getItem('selectedSeats')) if (selectedSeats !== null &amp;&amp; selectedSeats.length &gt; 0) { seats.forEach((seat, index) =&gt; { if (selectedSeats.indexOf(index) &gt; -1) { seat.classList.add('selected') } }) } const selectedMovieIndex = localStorage.getItem('selectedMovieIndex') if (selectedMovieIndex !== null) { movieSelect.selectedIndex = selectedMovieIndex }}populateUI()// 監聽容器內座位數值的變化container.addEventListener('click', (e) =&gt; { // contains 會返回一個 boolean 值 if ( e.target.classList.contains('seat') &amp;&amp; !e.target.classList.contains('occupied') ) { e.target.classList.toggle('selected') updateSelectCount() }})updateSelectCount() 參考資料JavaScript Array 陣列操作方法大全 ( 含 ES6 )20 Web Projects With Vanilla JavaScript","link":"/2021/01/16/JavaScript%20-%20Movie-seat-booking/"},{"title":"Python - 用 python flask 在本地端架設後端 server 進行 api 串接練習","text":"最近在寫個人的 side project ，由於 api 都是由後端提供，但是要讓 api 運作就是要開啟後端的 server ，這樣前端打 api 就可以會收到 response。 工作環境: window執行系統: WSL開發工具: VS Code虛擬機: Ubuntu 18.04 如果沒有 Ubuntu 18.04 要先安裝。 切換 WSL 系統在 VS Code 開啟終端機 ( ctrl + ~ )把開發環境切換到 WSL 選擇 WSL 選擇 WSL 後再點擊 + 就會多新增一個 WSL 執行開好 WSL 後執行 12sudo apt updatesudo apt -y upgrade 執行 sudo apt update 這段指令會安裝 10~20 分鐘左右。 結束後，在下 sudo apt -y upgrade 指令，繼續安裝。 安裝好後，確認 python 版本 python3 -V 卻認為 python3 的版本 在執行 sudo apt install -y python3-pip 指令 安裝好後還看看後端寫的啟動本地 server 的指令 12345pip3 install -r requirements.txtpython3 init.pypython3 run.py 如果執行完出現Could not open requirements file: [Errno 2] No such file or directory: ‘req的訊息就表示，檔案路徑不對，不應該是 window 下的檔案而是 linux 下的檔案，如下圖 一開始我的檔案路徑是在 window 下，然後我 cd 切回根目錄，再用 ls 看一下檔案， 再 cd 切到我要的檔案裏面，然後再執行一次 pip3 install -r requirements.txt。 然後就可以順利安裝了。 會出現 zsh: command not found: python 這個訊息是因為，我沒有將 python 指定成 python3 的版本，改用 python3 就可以正常運作了，如下圖。 再執行 python3 run.py 就可以正常運作了。 但系統會告知你，此為開發使用的，請不要再線上的產品使用。 參考資料如何在 Ubuntu 18.04 上安裝 Python 3 並建立本地編程環境","link":"/2021/03/31/python_flask/"},{"title":"JavaScript - 作用域 ( Scope )","text":"最近要面臨面試了，而這些東西都是面試必考的觀念，所以就將這些東西寫成一篇筆記，方便日後回顧。 全域變數與區域變數參考自 kuro 大大的 : 0 陷阱！0 誤解！8 天重新認識 JavaScript！ 其實在 JavaScript 這門語言中，沒有所謂「全域變數」這種東西。更準確地說，我們所說的「全域變數」其實指的是「全域物件」(或者叫「頂層物件」) 的屬性。 以瀏覽器來說，「全域物件」指的就是 window，在 node 環境中則叫做 global。 所有沒有透過 var 宣告的變數都會自動變成全域變數。 切分變數有效範圍的最小單位是 function ，而這範圍就是 Scope。 1. 如果在 function 內找不到 var 宣告的變數，就會一層層往外找，直到找到全域變數為止。以下示範: 123456var a = 10function fn() { console.log(a) // 10}fn() 用 window.a 看，確定變數 a 是全域變數。 2. 沒有透過 var 宣告的變數都會自動變成全域變數。函式裡面因為沒有使用 var 宣告變數 a ，所以變數 a 會變成全域變數並且直接覆蓋掉外層用 var 宣告的 a。 12345678var a = 10function fn() { a = '全域變數' console.log('我是 fn 裡面的 a =&gt; ' + a) // \"我是 fn 裡面的 a =&gt; 全域變數\"}fn()console.log('我是 fn 外面的 a =&gt; ' + a) // \"我是 fn 外面的 a =&gt; 全域變數\" 用 window.a 看，確定變數 a 是全域變數，不是 var 宣告的變數 10。 3. 但是如果函式內的 a 有用 var 宣告呢?12345678var a = 10function fn() { var a = '全域變數' console.log('我是 fn 裡面的 a =&gt; ' + a) // \"我是 fn 裡面的 a =&gt; 全域變數\"}fn()console.log('我是 fn 外面的 a =&gt; ' + a) // \"我是 fn 外面的 a =&gt; 10\" 如下圖，用 window.a 看，會發現全域變數的 a 是 10。 因為 var 的作用域會在 function 裡面，所以不會影響到外層的變數 a ，但外層宣告的變數 a 並沒有被 function 限制住，所以就會變成全域變數，以引用 Kuro 大大的結論： 變數有效範圍 ( scope ) 的最小切分單位是 function ( ES6 的 let 與 const 例外 ) 即使是寫在函式內，沒有 var 的變數會變成「全域變數」 全域變數指的是全域物件 ( 頂層物件 ) 的「屬性」 DEMO 函式與作用域之間的關係1. 全域執行環境 ( Global Level Scope )先來個最基本的，用 var 命名的 變數 a 然後賦值為 全域 a。 12var a = '全域 a'console.log(a) 2. 函式與全域作用域 ( Function Level Scope )然後在 function 裡面呼叫 a 變數，結果會是 全域 a ，因為當函式執行時如果函式內找不到變數就會向外層尋找。 12345678var a = '全域 a'function fn() { console.log(a) // 全域 a}console.log(a) // 全域 afn() 如下圖 所以在函式內如果找到命名的變數就不會向函式外層尋找，如下 123456789var a = '全域 a'function fn() { var a = '區域 a' console.log(a) // 區域 a}console.log(a) // 全域 afn() 為什麼會先顯示 全域 a ?因為在 24 行我先執行了 console.log(a)。之後 25 行再執行 fn 函式，這時候函式才會執行 function 裡面的 console.log(a)。 為了看更清楚，同時在函式外命名兩個變數，但在函式內只命一個 變數 a，結果如下。 123456789101112var a = '全域 a'var b = '全域 b'function fn() { var a = '區域 a' console.log('fn 裡面的 =&gt; ' + a) //\"fn 裡面的 =&gt; 區域 a\" console.log('fn 裡面的 =&gt; ' + b) //\"fn 裡面的 =&gt; 全域 b\"}console.log('fn 外面的 =&gt; ' + a) //\"fn 外面的 =&gt; 全域 a\"console.log('fn 外面的 =&gt; ' + b) //\"fn 外面的 =&gt; 全域 b\"fn() 結果如下，在函式內有找到變數 a 就不會向函式外層尋找，但函式內找不到變數 b ，所以就會向函式外層尋找全域 b。 ( 跟前一個例子同理，顯示的順序跟執行的順序一樣，先執行先顯示。 ) 同樣道理，如果我把函式外的 全域變數 b 註解掉，那函式內的 b 就會找不到該變數，會顯示為定義，如下圖 來點變化題，這會用到 JS 的 hoisting 觀念 12345678910var a = '全域 a'function fn() { console.log(a) // undefined var a = '區域 a' console.log(a) // \"區域 a\"}console.log(a) // \"全域 a\"fn() 結果如下圖 按照剛才觀念，函式內的 a 不是會像外層尋找? 或是在函式內有命名變數了，為什麼還找不到? 為甚麼會顯示為定義? 因為 JS 有 hoisting 變數提升的特性，所以當電腦在讀取的時候會變成下面這樣 123456789101112var a = '全域 a'function fn() { var a console.log(a) // undefined a = '區域 a' console.log(a) // \"區域 a\"}console.log(a) // \"全域 a\"fn() 第一個變數已經命名了但是沒有賦值，所以會顯示 undefined ，第二個變數是已經賦值了，所以會顯示 value 值。 DEMO 3. 塊級作用域 ( Block Level Scope, ES6 )以上是用 function 並在 function 內呼叫變數，接下來試用區塊，區塊就是指大括號 {} ，像是 if 判段式或是 for 迴圈這種的。 接下來就是用區塊 ( Block ) 不是用 function ，直接看程式碼。 1234var a = 10if (true) { console.log(a) // 10} 在區塊裡面沒有命名 變數 a ，所以會去外層全域找。 在區塊裡面跟外面同時看變數 a 的結果。 1234567var a = 10if (true) { var a = 20 console.log('區塊裡面 =&gt; ' + a)}console.log('區塊外面 =&gt; ' + a) 用開發者工具查看，會看到 a 抓到的值都是 20。 因為是塊及作用域的關係，所以用 var 命名的變數並不會被限制住，會直接覆蓋掉之前相同變數的值。 但這是用 var 來命名，如果用 ES6 的 let 命名變數的話就會被限制在區塊以內，如下 12345678910var a = 10if (true) { var a = 20 let b = 30 console.log('區塊裡面 =&gt; ' + a) console.log('區塊裡面 =&gt; ' + b)}console.log('區塊外面 =&gt; ' + a)console.log('區塊外面 =&gt; ' + b) 顯示下圖 因為在區塊裡面使用 let 命名變數 b ，所以變數 b 就會被限制在區塊裡面，那外層的 b 就會找不到。 參考資料[JS] Scope 作用域[筆記] JavaScript 變數宣告與作用域block重新認識 JavaScript: Day 10 函式 Functions 的基本概念","link":"/2021/04/08/Scope/"}],"tags":[{"name":"d-flex","slug":"d-flex","link":"/tags/d-flex/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"MVVM","slug":"MVVM","link":"/tags/MVVM/"},{"name":"v-if","slug":"v-if","link":"/tags/v-if/"},{"name":"v-on","slug":"v-on","link":"/tags/v-on/"},{"name":"v-model","slug":"v-model","link":"/tags/v-model/"},{"name":"執行環境","slug":"執行環境","link":"/tags/%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"v-bind","slug":"v-bind","link":"/tags/v-bind/"},{"name":"eventListener","slug":"eventListener","link":"/tags/eventListener/"},{"name":"callback function","slug":"callback-function","link":"/tags/callback-function/"},{"name":"event","slug":"event","link":"/tags/event/"},{"name":"onSubmit","slug":"onSubmit","link":"/tags/onSubmit/"},{"name":"preventDefault","slug":"preventDefault","link":"/tags/preventDefault/"},{"name":"stop","slug":"stop","link":"/tags/stop/"},{"name":"self","slug":"self","link":"/tags/self/"},{"name":"component","slug":"component","link":"/tags/component/"},{"name":"Router","slug":"Router","link":"/tags/Router/"},{"name":"computed","slug":"computed","link":"/tags/computed/"},{"name":"8-1用 v-for 把陣列轉換為一組元素","slug":"8-1用-v-for-把陣列轉換為一組元素","link":"/tags/8-1%E7%94%A8-v-for-%E6%8A%8A%E9%99%A3%E5%88%97%E8%BD%89%E6%8F%9B%E7%82%BA%E4%B8%80%E7%B5%84%E5%85%83%E7%B4%A0/"},{"name":"8-2用 v-for 把一個物件轉換為一組元素","slug":"8-2用-v-for-把一個物件轉換為一組元素","link":"/tags/8-2%E7%94%A8-v-for-%E6%8A%8A%E4%B8%80%E5%80%8B%E7%89%A9%E4%BB%B6%E8%BD%89%E6%8F%9B%E7%82%BA%E4%B8%80%E7%B5%84%E5%85%83%E7%B4%A0/"},{"name":"8-3修改陣列或物件的注意事項","slug":"8-3修改陣列或物件的注意事項","link":"/tags/8-3%E4%BF%AE%E6%94%B9%E9%99%A3%E5%88%97%E6%88%96%E7%89%A9%E4%BB%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85/"},{"name":"OWASP","slug":"OWASP","link":"/tags/OWASP/"},{"name":"WSL1","slug":"WSL1","link":"/tags/WSL1/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Pull Request","slug":"Pull-Request","link":"/tags/Pull-Request/"},{"name":"git clone","slug":"git-clone","link":"/tags/git-clone/"},{"name":"git pull","slug":"git-pull","link":"/tags/git-pull/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"作品集","slug":"作品集","link":"/tags/%E4%BD%9C%E5%93%81%E9%9B%86/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"filter","slug":"filter","link":"/tags/filter/"},{"name":"forEach","slug":"forEach","link":"/tags/forEach/"},{"name":"find","slug":"find","link":"/tags/find/"},{"name":"var","slug":"var","link":"/tags/var/"},{"name":"let","slug":"let","link":"/tags/let/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"JavaScrip","slug":"JavaScrip","link":"/tags/JavaScrip/"},{"name":"偽元素","slug":"偽元素","link":"/tags/%E5%81%BD%E5%85%83%E7%B4%A0/"},{"name":"dragDrop","slug":"dragDrop","link":"/tags/dragDrop/"},{"name":"mustache","slug":"mustache","link":"/tags/mustache/"},{"name":"v-once","slug":"v-once","link":"/tags/v-once/"},{"name":"v-html","slug":"v-html","link":"/tags/v-html/"},{"name":"v-text","slug":"v-text","link":"/tags/v-text/"},{"name":"v-show","slug":"v-show","link":"/tags/v-show/"},{"name":"components","slug":"components","link":"/tags/components/"},{"name":"data 函數","slug":"data-函數","link":"/tags/data-%E5%87%BD%E6%95%B8/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"props","slug":"props","link":"/tags/props/"},{"name":"Loading","slug":"Loading","link":"/tags/Loading/"},{"name":"arrow function","slug":"arrow-function","link":"/tags/arrow-function/"},{"name":"Hoisting","slug":"Hoisting","link":"/tags/Hoisting/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"WSL","slug":"WSL","link":"/tags/WSL/"},{"name":"Scope","slug":"Scope","link":"/tags/Scope/"}],"categories":[{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Flex","slug":"Flex","link":"/categories/Flex/"},{"name":"電商網站","slug":"電商網站","link":"/categories/%E9%9B%BB%E5%95%86%E7%B6%B2%E7%AB%99/"},{"name":"ZAP","slug":"ZAP","link":"/categories/ZAP/"},{"name":"WSL1","slug":"WSL1","link":"/categories/WSL1/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Pull Request","slug":"Pull-Request","link":"/categories/Pull-Request/"},{"name":"Cookie","slug":"Cookie","link":"/categories/Cookie/"},{"name":"LocalStorage","slug":"Cookie/LocalStorage","link":"/categories/Cookie/LocalStorage/"},{"name":"SessionStorage","slug":"Cookie/LocalStorage/SessionStorage","link":"/categories/Cookie/LocalStorage/SessionStorage/"},{"name":"JavaScrip","slug":"JavaScrip","link":"/categories/JavaScrip/"},{"name":"v-bind","slug":"v-bind","link":"/categories/v-bind/"},{"name":"mustache","slug":"v-bind/mustache","link":"/categories/v-bind/mustache/"},{"name":"v-once","slug":"v-bind/mustache/v-once","link":"/categories/v-bind/mustache/v-once/"},{"name":"v-html","slug":"v-bind/mustache/v-once/v-html","link":"/categories/v-bind/mustache/v-once/v-html/"},{"name":"v-text","slug":"v-bind/mustache/v-once/v-html/v-text","link":"/categories/v-bind/mustache/v-once/v-html/v-text/"},{"name":"Vue","slug":"v-bind/mustache/v-once/v-html/v-text/Vue","link":"/categories/v-bind/mustache/v-once/v-html/v-text/Vue/"},{"name":"computed","slug":"Vue/computed","link":"/categories/Vue/computed/"},{"name":"v-on","slug":"Vue/computed/v-on","link":"/categories/Vue/computed/v-on/"},{"name":"作品集","slug":"JavaScript/作品集","link":"/categories/JavaScript/%E4%BD%9C%E5%93%81%E9%9B%86/"},{"name":"Loading","slug":"Loading","link":"/categories/Loading/"},{"name":"this","slug":"JavaScrip/this","link":"/categories/JavaScrip/this/"},{"name":"arrow function","slug":"JavaScrip/this/arrow-function","link":"/categories/JavaScrip/this/arrow-function/"},{"name":"Hoisting","slug":"JavaScrip/Hoisting","link":"/categories/JavaScrip/Hoisting/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"WSL","slug":"Python/WSL","link":"/categories/Python/WSL/"},{"name":"Scope","slug":"JavaScrip/Scope","link":"/categories/JavaScrip/Scope/"}]}